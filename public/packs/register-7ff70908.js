
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { R as Input, T as binding_callbacks, U as bind, c as create_component, h as space, m as mount_component, i as insert_dev, V as add_flush_callback, t as transition_in, a as transition_out, d as destroy_component, f as detach_dev, b as dispatch_dev, F as FormGroup, W as SvelteToast, G as element, e as text, Y as attr_dev, I as add_location, J as append_dev, N as listen_dev, Z as prevent_default, s as set_data_dev, v as validate_store, X, n as component_subscribe, o as validate_slots, _ as User, $ as toast, S as SvelteComponentDev, p as init, q as safe_not_equal } from './bundle.js';
import { a as Form_1, F as Field, S as Select } from './index-69c2fccd.js';

/* app/javascript/pages/register.svelte generated by Svelte v3.37.0 */
const file = "app/javascript/pages/register.svelte";

// (28:2) <FormGroup>
function create_default_slot(ctx) {
	let input0;
	let updating_value;
	let t0;
	let input1;
	let updating_value_1;
	let t1;
	let input2;
	let updating_value_2;
	let t2;
	let input3;
	let updating_value_3;
	let current;

	function input0_value_binding(value) {
		/*input0_value_binding*/ ctx[6](value);
	}

	let input0_props = {
		placeholder: "Почта",
		type: "email",
		name: "email"
	};

	if (/*email*/ ctx[0] !== void 0) {
		input0_props.value = /*email*/ ctx[0];
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, "value", input0_value_binding));

	function input1_value_binding(value) {
		/*input1_value_binding*/ ctx[7](value);
	}

	let input1_props = {
		placeholder: "Пароль",
		type: "password",
		name: "password",
		autocomplete: "on"
	};

	if (/*password*/ ctx[1] !== void 0) {
		input1_props.value = /*password*/ ctx[1];
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, "value", input1_value_binding));

	function input2_value_binding(value) {
		/*input2_value_binding*/ ctx[8](value);
	}

	let input2_props = {
		placeholder: "Еще раз",
		type: "password",
		name: "password_confirmation",
		autocomplete: "on"
	};

	if (/*passwordConfirmation*/ ctx[2] !== void 0) {
		input2_props.value = /*passwordConfirmation*/ ctx[2];
	}

	input2 = new Input({ props: input2_props, $$inline: true });
	binding_callbacks.push(() => bind(input2, "value", input2_value_binding));

	function input3_value_binding(value) {
		/*input3_value_binding*/ ctx[9](value);
	}

	let input3_props = {
		type: "hidden",
		name: "authenticity_token"
	};

	if (/*csrf*/ ctx[3] !== void 0) {
		input3_props.value = /*csrf*/ ctx[3];
	}

	input3 = new Input({ props: input3_props, $$inline: true });
	binding_callbacks.push(() => bind(input3, "value", input3_value_binding));

	const block = {
		c: function create() {
			create_component(input0.$$.fragment);
			t0 = space();
			create_component(input1.$$.fragment);
			t1 = space();
			create_component(input2.$$.fragment);
			t2 = space();
			create_component(input3.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(input1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(input2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(input3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input0_changes = {};

			if (!updating_value && dirty & /*email*/ 1) {
				updating_value = true;
				input0_changes.value = /*email*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*password*/ 2) {
				updating_value_1 = true;
				input1_changes.value = /*password*/ ctx[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
			const input2_changes = {};

			if (!updating_value_2 && dirty & /*passwordConfirmation*/ 4) {
				updating_value_2 = true;
				input2_changes.value = /*passwordConfirmation*/ ctx[2];
				add_flush_callback(() => updating_value_2 = false);
			}

			input2.$set(input2_changes);
			const input3_changes = {};

			if (!updating_value_3 && dirty & /*csrf*/ 8) {
				updating_value_3 = true;
				input3_changes.value = /*csrf*/ ctx[3];
				add_flush_callback(() => updating_value_3 = false);
			}

			input3.$set(input3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(input2.$$.fragment, local);
			transition_in(input3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(input2.$$.fragment, local);
			transition_out(input3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(input1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(input2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(input3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(28:2) <FormGroup>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let form;
	let formgroup;
	let t0;
	let button;
	let t1_value = /*$_*/ ctx[4]("register") + "";
	let t1;
	let t2;
	let sveltetoast;
	let current;
	let mounted;
	let dispose;

	formgroup = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	sveltetoast = new SvelteToast({ $$inline: true });

	const block = {
		c: function create() {
			form = element("form");
			create_component(formgroup.$$.fragment);
			t0 = space();
			button = element("button");
			t1 = text(t1_value);
			t2 = space();
			create_component(sveltetoast.$$.fragment);
			attr_dev(button, "class", "btn btn-secondary");
			add_location(button, file, 35, 2, 1302);
			attr_dev(form, "method", "post");
			attr_dev(form, "action", "/api/v1/auth/register");
			add_location(form, file, 26, 0, 826);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			mount_component(formgroup, form, null);
			append_dev(form, t0);
			append_dev(form, button);
			append_dev(button, t1);
			append_dev(form, t2);
			mount_component(sveltetoast, form, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", prevent_default(/*formSubmit*/ ctx[5]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const formgroup_changes = {};

			if (dirty & /*$$scope, csrf, passwordConfirmation, password, email*/ 2063) {
				formgroup_changes.$$scope = { dirty, ctx };
			}

			formgroup.$set(formgroup_changes);
			if ((!current || dirty & /*$_*/ 16) && t1_value !== (t1_value = /*$_*/ ctx[4]("register") + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formgroup.$$.fragment, local);
			transition_in(sveltetoast.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formgroup.$$.fragment, local);
			transition_out(sveltetoast.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_component(formgroup);
			destroy_component(sveltetoast);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $_;
	validate_store(X, "_");
	component_subscribe($$self, X, $$value => $$invalidate(4, $_ = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Register", slots, []);
	let email, password, passwordConfirmation;
	let csrf = document.querySelector("meta[name=csrf-token]").content;
	let param = document.querySelector("meta[name=csrf-param]").content;

	async function formSubmit(data) {
		let res = await User.register(email, password, passwordConfirmation);

		if (res.errors) {
			toast.push(res.errors.join("<br />"));
		} else {
			User.signIn(res.token);
			toast.push("Вы зарегистрировались " + res.data["email"]);
			window.location = "/";
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Register> was created with unknown prop '${key}'`);
	});

	function input0_value_binding(value) {
		email = value;
		$$invalidate(0, email);
	}

	function input1_value_binding(value) {
		password = value;
		$$invalidate(1, password);
	}

	function input2_value_binding(value) {
		passwordConfirmation = value;
		$$invalidate(2, passwordConfirmation);
	}

	function input3_value_binding(value) {
		csrf = value;
		$$invalidate(3, csrf);
	}

	$$self.$capture_state = () => ({
		User,
		Form: Form_1,
		Field,
		Select,
		SvelteToast,
		toast,
		FormGroup,
		Input,
		_: X,
		email,
		password,
		passwordConfirmation,
		csrf,
		param,
		formSubmit,
		$_
	});

	$$self.$inject_state = $$props => {
		if ("email" in $$props) $$invalidate(0, email = $$props.email);
		if ("password" in $$props) $$invalidate(1, password = $$props.password);
		if ("passwordConfirmation" in $$props) $$invalidate(2, passwordConfirmation = $$props.passwordConfirmation);
		if ("csrf" in $$props) $$invalidate(3, csrf = $$props.csrf);
		if ("param" in $$props) param = $$props.param;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		email,
		password,
		passwordConfirmation,
		csrf,
		$_,
		formSubmit,
		input0_value_binding,
		input1_value_binding,
		input2_value_binding,
		input3_value_binding
	];
}

class Register extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Register",
			options,
			id: create_fragment.name
		});
	}
}

export default Register;
//# sourceMappingURL=register-7ff70908.js.map
