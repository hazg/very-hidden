
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { c as assign, e as element, f as space, g as set_attributes, h as add_location, i as insert_dev, j as append_dev, k as group_outros, l as transition_out, m as check_outros, o as transition_in, p as get_spread_update, q as add_render_callback, r as create_bidirectional_transition, u as fade, d as detach_dev, a as dispatch_dev, w as attr_dev, x as listen_dev, y as is_function, z as create_slot, A as update_slot, t as text, B as set_data_dev, n as noop$1, C as empty, D as compute_rest_props, v as validate_slots, E as exclude_internal_props, S as SvelteComponentDev, b as init, s as safe_not_equal, F as bubble, G as writable, H as globals, I as setContext, J as binding_callbacks, K as create_component, L as mount_component, M as get_spread_object, N as destroy_component, O as run_all, P as onMount, Q as onDestroy, R as prevent_default, T as toggle_class, U as validate_each_argument, V as destroy_each, W as slide, X as createEventDispatcher, Y as select_options, Z as select_option, _ as select_value, $ as getContext, a0 as validate_store, a1 as component_subscribe, a2 as set_input_value, a3 as to_number, a4 as afterUpdate, a5 as set_style, a6 as svg_element, a7 as bind, a8 as add_flush_callback, a9 as SvelteToast, aa as User, ab as toast } from './bundle.js';

function getOriginalBodyPadding() {
  const style = window ? window.getComputedStyle(document.body, null) : {};

  return parseInt((style && style.getPropertyValue('padding-right')) || 0, 10);
}

function getScrollbarWidth() {
  let scrollDiv = document.createElement('div');
  // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113
  scrollDiv.style.position = 'absolute';
  scrollDiv.style.top = '-9999px';
  scrollDiv.style.width = '50px';
  scrollDiv.style.height = '50px';
  scrollDiv.style.overflow = 'scroll';
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}

function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
}

function isBodyOverflowing() {
  return window ? document.body.clientWidth < window.innerWidth : false;
}

function isObject(value) {
  const type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

function conditionallyUpdateScrollbar() {
  const scrollbarWidth = getScrollbarWidth();
  // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.6/js/src/modal.js#L433
  const fixedContent = document.querySelectorAll(
    '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'
  )[0];
  const bodyPadding = fixedContent
    ? parseInt(fixedContent.style.paddingRight || 0, 10)
    : 0;

  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}

function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === '') {
    return isXs ? 'col' : `col-${colWidth}`;
  } else if (colSize === 'auto') {
    return isXs ? 'col-auto' : `col-${colWidth}-auto`;
  }

  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}

function clean($$props) {
  // TODO support keys
  // eslint-disable-next-line no-unused-vars
  const { children, $$scope, $$slots } = $$props;
  const rest = {};
  for (const key of Object.keys($$props)) {
    if (key !== 'children' && key !== '$$scope' && key !== '$$slots') {
      rest[key] = $$props[key];
    }
  }
  return rest;
}

function browserEvent(target, ...args) {
  target.addEventListener(...args);

  return () => target.removeEventListener(...args);
}

function getNewCarouselActiveIndex(direction, items, activeIndex) {
  if (direction === 'prev') {
    return activeIndex === 0 ? items.length - 1 : activeIndex - 1;
  } else if (direction === 'next') {
    return activeIndex === items.length - 1 ? 0 : activeIndex + 1;
  }
}

function toClassName(value) {
  let result = '';

  if (typeof value === 'string' || typeof value === 'number') {
    result += value;
  } else if (typeof value === 'object') {
    if (Array.isArray(value)) {
      result = value.map(toClassName).filter(Boolean).join(' ');
    } else {
      for (let key in value) {
        if (value[key]) {
          result && (result += ' ');
          result += key;
        }
      }
    }
  }

  return result;
}

function classnames(...args) {
  return args.map(toClassName).filter(Boolean).join(' ');
}

/* node_modules/sveltestrap/src/Alert.svelte generated by Svelte v3.37.0 */
const file = "node_modules/sveltestrap/src/Alert.svelte";

// (22:0) {#if isOpen}
function create_if_block(ctx) {
	let div;
	let t;
	let current_block_type_index;
	let if_block1;
	let div_transition;
	let current;
	let if_block0 = /*toggle*/ ctx[3] && create_if_block_2(ctx);
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let div_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[5] }, { role: "alert" }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			set_attributes(div, div_data);
			add_location(div, file, 22, 2, 637);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*toggle*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				{ role: "alert" }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, /*transition*/ ctx[4], true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, /*transition*/ ctx[4], false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(22:0) {#if isOpen}",
		ctx
	});

	return block;
}

// (28:4) {#if toggle}
function create_if_block_2(ctx) {
	let button;
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			span.textContent = "Ã—";
			attr_dev(span, "aria-hidden", "true");
			add_location(span, file, 33, 8, 900);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", /*closeClassNames*/ ctx[6]);
			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			add_location(button, file, 28, 6, 767);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*toggle*/ ctx[3])) /*toggle*/ ctx[3].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*closeClassNames*/ 64) {
				attr_dev(button, "class", /*closeClassNames*/ ctx[6]);
			}

			if (dirty & /*closeAriaLabel*/ 2) {
				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(28:4) {#if toggle}",
		ctx
	});

	return block;
}

// (39:4) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(39:4) {:else}",
		ctx
	});

	return block;
}

// (37:4) {#if children}
function create_if_block_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(37:4) {#if children}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let classes;
	let closeClassNames;

	const omit_props_names = [
		"class","children","color","closeClassName","closeAriaLabel","isOpen","toggle","fade","transition"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Alert", slots, ['default']);
	let { class: className = "" } = $$props;
	let { children = undefined } = $$props;
	let { color = "success" } = $$props;
	let { closeClassName = "" } = $$props;
	let { closeAriaLabel = "Close" } = $$props;
	let { isOpen = true } = $$props;
	let { toggle = undefined } = $$props;
	let { fade: fade$1 = true } = $$props;
	let { transition = { duration: fade$1 ? 400 : 0 } } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("children" in $$new_props) $$invalidate(0, children = $$new_props.children);
		if ("color" in $$new_props) $$invalidate(9, color = $$new_props.color);
		if ("closeClassName" in $$new_props) $$invalidate(10, closeClassName = $$new_props.closeClassName);
		if ("closeAriaLabel" in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ("isOpen" in $$new_props) $$invalidate(2, isOpen = $$new_props.isOpen);
		if ("toggle" in $$new_props) $$invalidate(3, toggle = $$new_props.toggle);
		if ("fade" in $$new_props) $$invalidate(11, fade$1 = $$new_props.fade);
		if ("transition" in $$new_props) $$invalidate(4, transition = $$new_props.transition);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		fadeTransition: fade,
		classnames,
		className,
		children,
		color,
		closeClassName,
		closeAriaLabel,
		isOpen,
		toggle,
		fade: fade$1,
		transition,
		classes,
		closeClassNames
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("children" in $$props) $$invalidate(0, children = $$new_props.children);
		if ("color" in $$props) $$invalidate(9, color = $$new_props.color);
		if ("closeClassName" in $$props) $$invalidate(10, closeClassName = $$new_props.closeClassName);
		if ("closeAriaLabel" in $$props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ("isOpen" in $$props) $$invalidate(2, isOpen = $$new_props.isOpen);
		if ("toggle" in $$props) $$invalidate(3, toggle = $$new_props.toggle);
		if ("fade" in $$props) $$invalidate(11, fade$1 = $$new_props.fade);
		if ("transition" in $$props) $$invalidate(4, transition = $$new_props.transition);
		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
		if ("closeClassNames" in $$props) $$invalidate(6, closeClassNames = $$new_props.closeClassNames);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, color, toggle*/ 776) {
			$: $$invalidate(5, classes = classnames(className, "alert", `alert-${color}`, { "alert-dismissible": toggle }));
		}

		if ($$self.$$.dirty & /*closeClassName*/ 1024) {
			$: $$invalidate(6, closeClassNames = classnames("close", closeClassName));
		}
	};

	return [
		children,
		closeAriaLabel,
		isOpen,
		toggle,
		transition,
		classes,
		closeClassNames,
		$$restProps,
		className,
		color,
		closeClassName,
		fade$1,
		$$scope,
		slots
	];
}

class Alert extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			class: 8,
			children: 0,
			color: 9,
			closeClassName: 10,
			closeAriaLabel: 1,
			isOpen: 2,
			toggle: 3,
			fade: 11,
			transition: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Alert",
			options,
			id: create_fragment.name
		});
	}

	get class() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeClassName() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeClassName(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeAriaLabel() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeAriaLabel(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fade() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fade(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transition() {
		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transition(value) {
		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Badge.svelte generated by Svelte v3.37.0 */
const file$1 = "node_modules/sveltestrap/src/Badge.svelte";

// (27:0) {:else}
function create_else_block_1(ctx) {
	let span;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_2$1, create_else_block_2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*children*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let span_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if_block.c();
			set_attributes(span, span_data);
			add_location(span, file$1, 27, 2, 501);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if_blocks[current_block_type_index].m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(span, null);
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(27:0) {:else}",
		ctx
	});

	return block;
}

// (19:0) {#if href}
function create_if_block$1(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*children*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		/*$$restProps*/ ctx[3],
		{ href: /*href*/ ctx[1] },
		{ class: /*classes*/ ctx[2] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if_block.c();
			set_attributes(a, a_data);
			add_location(a, file$1, 19, 2, 367);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(a, null);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(19:0) {#if href}",
		ctx
	});

	return block;
}

// (31:4) {:else}
function create_else_block_2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(31:4) {:else}",
		ctx
	});

	return block;
}

// (29:4) {#if children}
function create_if_block_2$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(29:4) {#if children}",
		ctx
	});

	return block;
}

// (23:4) {:else}
function create_else_block$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(23:4) {:else}",
		ctx
	});

	return block;
}

// (21:4) {#if children}
function create_if_block_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(21:4) {#if children}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","children","color","href","pill"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Badge", slots, ['default']);
	let { class: className = "" } = $$props;
	let { children = undefined } = $$props;
	let { color = "secondary" } = $$props;
	let { href = undefined } = $$props;
	let { pill = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("children" in $$new_props) $$invalidate(0, children = $$new_props.children);
		if ("color" in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
		if ("pill" in $$new_props) $$invalidate(6, pill = $$new_props.pill);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		children,
		color,
		href,
		pill,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("children" in $$props) $$invalidate(0, children = $$new_props.children);
		if ("color" in $$props) $$invalidate(5, color = $$new_props.color);
		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
		if ("pill" in $$props) $$invalidate(6, pill = $$new_props.pill);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, color, pill*/ 112) {
			$: $$invalidate(2, classes = classnames(className, "badge", `badge-${color}`, pill ? "badge-pill" : false));
		}
	};

	return [children, href, classes, $$restProps, className, color, pill, $$scope, slots];
}

class Badge extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			class: 4,
			children: 0,
			color: 5,
			href: 1,
			pill: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badge",
			options,
			id: create_fragment$1.name
		});
	}

	get class() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pill() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pill(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Breadcrumb.svelte generated by Svelte v3.37.0 */
const file$2 = "node_modules/sveltestrap/src/Breadcrumb.svelte";

// (17:4) {:else}
function create_else_block$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(17:4) {:else}",
		ctx
	});

	return block;
}

// (15:4) {#if children}
function create_if_block$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 4) set_data_dev(t, /*children*/ ctx[2]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(15:4) {#if children}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let nav;
	let ol;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let nav_levels = [
		/*$$restProps*/ ctx[4],
		{ "aria-label": /*ariaLabel*/ ctx[1] },
		{ class: /*className*/ ctx[0] }
	];

	let nav_data = {};

	for (let i = 0; i < nav_levels.length; i += 1) {
		nav_data = assign(nav_data, nav_levels[i]);
	}

	const block = {
		c: function create() {
			nav = element("nav");
			ol = element("ol");
			if_block.c();
			attr_dev(ol, "class", /*listClasses*/ ctx[3]);
			add_location(ol, file$2, 13, 2, 346);
			set_attributes(nav, nav_data);
			add_location(nav, file$2, 12, 0, 280);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, ol);
			if_blocks[current_block_type_index].m(ol, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(ol, null);
			}

			if (!current || dirty & /*listClasses*/ 8) {
				attr_dev(ol, "class", /*listClasses*/ ctx[3]);
			}

			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*ariaLabel*/ 2) && { "aria-label": /*ariaLabel*/ ctx[1] },
				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let listClasses;
	const omit_props_names = ["class","ariaLabel","children","listClassName"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Breadcrumb", slots, ['default']);
	let { class: className = "" } = $$props;
	let { ariaLabel = "breadcrumb" } = $$props;
	let { children = undefined } = $$props;
	let { listClassName = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("ariaLabel" in $$new_props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
		if ("children" in $$new_props) $$invalidate(2, children = $$new_props.children);
		if ("listClassName" in $$new_props) $$invalidate(5, listClassName = $$new_props.listClassName);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		ariaLabel,
		children,
		listClassName,
		listClasses
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("ariaLabel" in $$props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
		if ("children" in $$props) $$invalidate(2, children = $$new_props.children);
		if ("listClassName" in $$props) $$invalidate(5, listClassName = $$new_props.listClassName);
		if ("listClasses" in $$props) $$invalidate(3, listClasses = $$new_props.listClasses);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*listClassName*/ 32) {
			$: $$invalidate(3, listClasses = classnames("breadcrumb", listClassName));
		}
	};

	return [
		className,
		ariaLabel,
		children,
		listClasses,
		$$restProps,
		listClassName,
		$$scope,
		slots
	];
}

class Breadcrumb extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			class: 0,
			ariaLabel: 1,
			children: 2,
			listClassName: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Breadcrumb",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listClassName() {
		throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listClassName(value) {
		throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/BreadcrumbItem.svelte generated by Svelte v3.37.0 */
const file$3 = "node_modules/sveltestrap/src/BreadcrumbItem.svelte";

// (19:2) {:else}
function create_else_block$3(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(19:2) {:else}",
		ctx
	});

	return block;
}

// (17:2) {#if children}
function create_if_block$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(17:2) {#if children}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let li_aria_current_value;
	let current;
	const if_block_creators = [create_if_block$3, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let li_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] },
		{
			"aria-current": li_aria_current_value = /*active*/ ctx[0] ? "page" : undefined
		}
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if_block.c();
			set_attributes(li, li_data);
			add_location(li, file$3, 15, 0, 277);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(li, null);
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*active*/ 1 && li_aria_current_value !== (li_aria_current_value = /*active*/ ctx[0] ? "page" : undefined)) && { "aria-current": li_aria_current_value }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","children"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("BreadcrumbItem", slots, ['default']);
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { children = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(0, active = $$new_props.active);
		if ("children" in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		active,
		children,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(0, active = $$new_props.active);
		if ("children" in $$props) $$invalidate(1, children = $$new_props.children);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active*/ 17) {
			$: $$invalidate(2, classes = classnames(className, active ? "active" : false, "breadcrumb-item"));
		}
	};

	return [active, children, classes, $$restProps, className, $$scope, slots];
}

class BreadcrumbItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { class: 4, active: 0, children: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BreadcrumbItem",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Button.svelte generated by Svelte v3.37.0 */
const file$4 = "node_modules/sveltestrap/src/Button.svelte";

// (48:0) {:else}
function create_else_block_1$1(ctx) {
	let button;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	let button_levels = [
		/*$$restProps*/ ctx[9],
		{ class: /*classes*/ ctx[7] },
		{ disabled: /*disabled*/ ctx[2] },
		{ value: /*value*/ ctx[5] },
		{
			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8]
		},
		{ style: /*style*/ ctx[4] }
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block_1 = {
		c: function create() {
			button = element("button");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			set_attributes(button, button_data);
			add_location(button, file$4, 48, 2, 985);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[19], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*close, children, $$scope*/ 65539) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
				(!current || dirty & /*value*/ 32) && { value: /*value*/ ctx[5] },
				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8])) && { "aria-label": button_aria_label_value },
				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(48:0) {:else}",
		ctx
	});

	return block_1;
}

// (33:0) {#if href}
function create_if_block$4(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let a_aria_label_value;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$2, create_else_block$4];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*children*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		/*$$restProps*/ ctx[9],
		{ class: /*classes*/ ctx[7] },
		{ disabled: /*disabled*/ ctx[2] },
		{ href: /*href*/ ctx[3] },
		{
			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8]
		},
		{ style: /*style*/ ctx[4] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block_1 = {
		c: function create() {
			a = element("a");
			if_block.c();
			set_attributes(a, a_data);
			add_location(a, file$4, 33, 2, 752);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*click_handler*/ ctx[18], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(a, null);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] },
				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8])) && { "aria-label": a_aria_label_value },
				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_if_block$4.name,
		type: "if",
		source: "(33:0) {#if href}",
		ctx
	});

	return block_1;
}

// (62:6) {:else}
function create_else_block_2$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block_1 = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_else_block_2$1.name,
		type: "else",
		source: "(62:6) {:else}",
		ctx
	});

	return block_1;
}

// (60:25) 
function create_if_block_3(ctx) {
	let t;

	const block_1 = {
		c: function create() {
			t = text(/*children*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_if_block_3.name,
		type: "if",
		source: "(60:25) ",
		ctx
	});

	return block_1;
}

// (58:6) {#if close}
function create_if_block_2$2(ctx) {
	let span;

	const block_1 = {
		c: function create() {
			span = element("span");
			span.textContent = "Ã—";
			attr_dev(span, "aria-hidden", "true");
			add_location(span, file$4, 58, 8, 1171);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(58:6) {#if close}",
		ctx
	});

	return block_1;
}

// (57:10)        
function fallback_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$2, create_if_block_3, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*close*/ ctx[1]) return 0;
		if (/*children*/ ctx[0]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_2(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block_1 = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: fallback_block.name,
		type: "fallback",
		source: "(57:10)        ",
		ctx
	});

	return block_1;
}

// (44:4) {:else}
function create_else_block$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block_1 = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_else_block$4.name,
		type: "else",
		source: "(44:4) {:else}",
		ctx
	});

	return block_1;
}

// (42:4) {#if children}
function create_if_block_1$2(ctx) {
	let t;

	const block_1 = {
		c: function create() {
			t = text(/*children*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(42:4) {#if children}",
		ctx
	});

	return block_1;
}

function create_fragment$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block_1 = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block_1;
}

function instance$4($$self, $$props, $$invalidate) {
	let ariaLabel;
	let classes;
	let defaultAriaLabel;

	const omit_props_names = [
		"class","active","block","children","close","color","disabled","href","outline","size","style","value"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Button", slots, ['default']);
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { block = false } = $$props;
	let { children = undefined } = $$props;
	let { close = false } = $$props;
	let { color = "secondary" } = $$props;
	let { disabled = false } = $$props;
	let { href = "" } = $$props;
	let { outline = false } = $$props;
	let { size = null } = $$props;
	let { style = "" } = $$props;
	let { value = "" } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(11, active = $$new_props.active);
		if ("block" in $$new_props) $$invalidate(12, block = $$new_props.block);
		if ("children" in $$new_props) $$invalidate(0, children = $$new_props.children);
		if ("close" in $$new_props) $$invalidate(1, close = $$new_props.close);
		if ("color" in $$new_props) $$invalidate(13, color = $$new_props.color);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("href" in $$new_props) $$invalidate(3, href = $$new_props.href);
		if ("outline" in $$new_props) $$invalidate(14, outline = $$new_props.outline);
		if ("size" in $$new_props) $$invalidate(15, size = $$new_props.size);
		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		active,
		block,
		children,
		close,
		color,
		disabled,
		href,
		outline,
		size,
		style,
		value,
		ariaLabel,
		classes,
		defaultAriaLabel
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(10, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(11, active = $$new_props.active);
		if ("block" in $$props) $$invalidate(12, block = $$new_props.block);
		if ("children" in $$props) $$invalidate(0, children = $$new_props.children);
		if ("close" in $$props) $$invalidate(1, close = $$new_props.close);
		if ("color" in $$props) $$invalidate(13, color = $$new_props.color);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("href" in $$props) $$invalidate(3, href = $$new_props.href);
		if ("outline" in $$props) $$invalidate(14, outline = $$new_props.outline);
		if ("size" in $$props) $$invalidate(15, size = $$new_props.size);
		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
		if ("ariaLabel" in $$props) $$invalidate(6, ariaLabel = $$new_props.ariaLabel);
		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
		if ("defaultAriaLabel" in $$props) $$invalidate(8, defaultAriaLabel = $$new_props.defaultAriaLabel);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		$: $$invalidate(6, ariaLabel = $$props["aria-label"]);

		if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/ 64514) {
			$: $$invalidate(7, classes = classnames(className, { close }, close || "btn", close || `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "btn-block" : false, { active }));
		}

		if ($$self.$$.dirty & /*close*/ 2) {
			$: $$invalidate(8, defaultAriaLabel = close ? "Close" : null);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		children,
		close,
		disabled,
		href,
		style,
		value,
		ariaLabel,
		classes,
		defaultAriaLabel,
		$$restProps,
		className,
		active,
		block,
		color,
		outline,
		size,
		$$scope,
		slots,
		click_handler,
		click_handler_1
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			class: 10,
			active: 11,
			block: 12,
			children: 0,
			close: 1,
			color: 13,
			disabled: 2,
			href: 3,
			outline: 14,
			size: 15,
			style: 4,
			value: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$4.name
		});
	}

	get class() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get block() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set block(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set close(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const createContext = () => writable({});

/* node_modules/sveltestrap/src/Dropdown.svelte generated by Svelte v3.37.0 */

const { Error: Error_1 } = globals;
const file$5 = "node_modules/sveltestrap/src/Dropdown.svelte";

// (100:0) {:else}
function create_else_block$5(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$5, 100, 2, 2405);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[19](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[19](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(100:0) {:else}",
		ctx
	});

	return block;
}

// (96:0) {#if nav}
function create_if_block$5(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let li_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$5, 96, 2, 2314);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding*/ ctx[18](li);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[18](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(96:0) {#if nav}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nav*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let subItemIsActive;
	let classes;

	const omit_props_names = [
		"class","direction","group","isOpen","nav","active","addonType","size","toggle","inNavbar","setActiveFromChild","dropup"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Dropdown", slots, ['default']);
	let context = createContext();
	setContext("dropdownContext", context);
	let { class: className = "" } = $$props;
	let { direction = "down" } = $$props;
	let { group = false } = $$props;
	let { isOpen = false } = $$props;
	let { nav = false } = $$props;
	let { active = false } = $$props;
	let { addonType = false } = $$props;
	let { size = "" } = $$props;
	let { toggle = undefined } = $$props;
	let { inNavbar = false } = $$props;
	let { setActiveFromChild = false } = $$props;
	let { dropup = false } = $$props;
	const validDirections = ["up", "down", "left", "right"];

	if (validDirections.indexOf(direction) === -1) {
		throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right'`);
	}

	let component;

	function handleDocumentClick(e) {
		if (e && (e.which === 3 || e.type === "keyup" && e.which !== 9)) return;

		if (component.contains(e.target) && component !== e.target && (e.type !== "keyup" || e.which === 9)) {
			return;
		}

		toggle(e);
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			component = $$value;
			$$invalidate(1, component);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			component = $$value;
			$$invalidate(1, component);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("direction" in $$new_props) $$invalidate(5, direction = $$new_props.direction);
		if ("group" in $$new_props) $$invalidate(6, group = $$new_props.group);
		if ("isOpen" in $$new_props) $$invalidate(7, isOpen = $$new_props.isOpen);
		if ("nav" in $$new_props) $$invalidate(0, nav = $$new_props.nav);
		if ("active" in $$new_props) $$invalidate(8, active = $$new_props.active);
		if ("addonType" in $$new_props) $$invalidate(9, addonType = $$new_props.addonType);
		if ("size" in $$new_props) $$invalidate(10, size = $$new_props.size);
		if ("toggle" in $$new_props) $$invalidate(11, toggle = $$new_props.toggle);
		if ("inNavbar" in $$new_props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
		if ("setActiveFromChild" in $$new_props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("dropup" in $$new_props) $$invalidate(14, dropup = $$new_props.dropup);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		classnames,
		createContext,
		context,
		className,
		direction,
		group,
		isOpen,
		nav,
		active,
		addonType,
		size,
		toggle,
		inNavbar,
		setActiveFromChild,
		dropup,
		validDirections,
		component,
		handleDocumentClick,
		subItemIsActive,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("context" in $$props) $$invalidate(20, context = $$new_props.context);
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("direction" in $$props) $$invalidate(5, direction = $$new_props.direction);
		if ("group" in $$props) $$invalidate(6, group = $$new_props.group);
		if ("isOpen" in $$props) $$invalidate(7, isOpen = $$new_props.isOpen);
		if ("nav" in $$props) $$invalidate(0, nav = $$new_props.nav);
		if ("active" in $$props) $$invalidate(8, active = $$new_props.active);
		if ("addonType" in $$props) $$invalidate(9, addonType = $$new_props.addonType);
		if ("size" in $$props) $$invalidate(10, size = $$new_props.size);
		if ("toggle" in $$props) $$invalidate(11, toggle = $$new_props.toggle);
		if ("inNavbar" in $$props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
		if ("setActiveFromChild" in $$props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("dropup" in $$props) $$invalidate(14, dropup = $$new_props.dropup);
		if ("component" in $$props) $$invalidate(1, component = $$new_props.component);
		if ("subItemIsActive" in $$props) $$invalidate(15, subItemIsActive = $$new_props.subItemIsActive);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*setActiveFromChild, component*/ 8194) {
			$: $$invalidate(15, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === "function" && component.querySelector(".active")));
		}

		if ($$self.$$.dirty & /*className, direction, nav, active, setActiveFromChild, subItemIsActive, addonType, group, size, isOpen*/ 42993) {
			$: $$invalidate(2, classes = classnames(className, direction !== "down" && `drop${direction}`, nav && active ? "active" : false, setActiveFromChild && subItemIsActive ? "active" : false, {
				[`input-group-${addonType}`]: addonType,
				"btn-group": group,
				[`btn-group-${size}`]: !!size,
				dropdown: !group && !addonType,
				show: isOpen,
				"nav-item": nav
			}));
		}

		if ($$self.$$.dirty & /*isOpen*/ 128) {
			$: {
				if (typeof document !== "undefined") {
					if (isOpen) {
						["click", "touchstart", "keyup"].forEach(event => document.addEventListener(event, handleDocumentClick, true));
					} else {
						["click", "touchstart", "keyup"].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
					}
				}
			}
		}

		if ($$self.$$.dirty & /*toggle, isOpen, direction, dropup, inNavbar*/ 22688) {
			$: {
				context.update(() => {
					return {
						toggle,
						isOpen,
						direction: direction === "down" && dropup ? "up" : direction,
						inNavbar
					};
				});
			}
		}
	};

	return [
		nav,
		component,
		classes,
		$$restProps,
		className,
		direction,
		group,
		isOpen,
		active,
		addonType,
		size,
		toggle,
		inNavbar,
		setActiveFromChild,
		dropup,
		subItemIsActive,
		$$scope,
		slots,
		li_binding,
		div_binding
	];
}

class Dropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			class: 4,
			direction: 5,
			group: 6,
			isOpen: 7,
			nav: 0,
			active: 8,
			addonType: 9,
			size: 10,
			toggle: 11,
			inNavbar: 12,
			setActiveFromChild: 13,
			dropup: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dropdown",
			options,
			id: create_fragment$5.name
		});
	}

	get class() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nav() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nav(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addonType() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addonType(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inNavbar() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inNavbar(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setActiveFromChild() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setActiveFromChild(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropup() {
		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropup(value) {
		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ButtonDropdown.svelte generated by Svelte v3.37.0 */
const file$6 = "node_modules/sveltestrap/src/ButtonDropdown.svelte";

// (20:0) <Dropdown   {...$$restProps}   {group}   class={className}   {disabled}   {direction}   {isOpen}   {nav}   {active}   {addonType}   {size}   {toggle}   {inNavbar}   {setActiveFromChild}   {dropup}   on:click>
function create_default_slot(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(20:0) <Dropdown   {...$$restProps}   {group}   class={className}   {disabled}   {direction}   {isOpen}   {nav}   {active}   {addonType}   {size}   {toggle}   {inNavbar}   {setActiveFromChild}   {dropup}   on:click>",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let dropdown;
	let current;

	const dropdown_spread_levels = [
		/*$$restProps*/ ctx[13],
		{ group: /*group*/ ctx[6] },
		{ class: /*className*/ ctx[0] },
		{ disabled: /*disabled*/ ctx[4] },
		{ direction: /*direction*/ ctx[3] },
		{ isOpen: /*isOpen*/ ctx[8] },
		{ nav: /*nav*/ ctx[9] },
		{ active: /*active*/ ctx[1] },
		{ addonType: /*addonType*/ ctx[2] },
		{ size: /*size*/ ctx[11] },
		{ toggle: /*toggle*/ ctx[12] },
		{ inNavbar: /*inNavbar*/ ctx[7] },
		{
			setActiveFromChild: /*setActiveFromChild*/ ctx[10]
		},
		{ dropup: /*dropup*/ ctx[5] }
	];

	let dropdown_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
		dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
	}

	dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
	dropdown.$on("click", /*click_handler*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(dropdown.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dropdown, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dropdown_changes = (dirty & /*$$restProps, group, className, disabled, direction, isOpen, nav, active, addonType, size, toggle, inNavbar, setActiveFromChild, dropup*/ 16383)
			? get_spread_update(dropdown_spread_levels, [
					dirty & /*$$restProps*/ 8192 && get_spread_object(/*$$restProps*/ ctx[13]),
					dirty & /*group*/ 64 && { group: /*group*/ ctx[6] },
					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] },
					dirty & /*disabled*/ 16 && { disabled: /*disabled*/ ctx[4] },
					dirty & /*direction*/ 8 && { direction: /*direction*/ ctx[3] },
					dirty & /*isOpen*/ 256 && { isOpen: /*isOpen*/ ctx[8] },
					dirty & /*nav*/ 512 && { nav: /*nav*/ ctx[9] },
					dirty & /*active*/ 2 && { active: /*active*/ ctx[1] },
					dirty & /*addonType*/ 4 && { addonType: /*addonType*/ ctx[2] },
					dirty & /*size*/ 2048 && { size: /*size*/ ctx[11] },
					dirty & /*toggle*/ 4096 && { toggle: /*toggle*/ ctx[12] },
					dirty & /*inNavbar*/ 128 && { inNavbar: /*inNavbar*/ ctx[7] },
					dirty & /*setActiveFromChild*/ 1024 && {
						setActiveFromChild: /*setActiveFromChild*/ ctx[10]
					},
					dirty & /*dropup*/ 32 && { dropup: /*dropup*/ ctx[5] }
				])
			: {};

			if (dirty & /*$$scope*/ 65536) {
				dropdown_changes.$$scope = { dirty, ctx };
			}

			dropdown.$set(dropdown_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dropdown, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","active","addonType","direction","disabled","dropup","group","inNavbar","isOpen","nav","setActiveFromChild","size","toggle"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ButtonDropdown", slots, ['default']);
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { addonType = false } = $$props;
	let { direction = "down" } = $$props;
	let { disabled = false } = $$props;
	let { dropup = false } = $$props;
	let { group = false } = $$props;
	let { inNavbar = false } = $$props;
	let { isOpen = false } = $$props;
	let { nav = false } = $$props;
	let { setActiveFromChild = false } = $$props;
	let { size = "" } = $$props;
	let { toggle = undefined } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(1, active = $$new_props.active);
		if ("addonType" in $$new_props) $$invalidate(2, addonType = $$new_props.addonType);
		if ("direction" in $$new_props) $$invalidate(3, direction = $$new_props.direction);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("dropup" in $$new_props) $$invalidate(5, dropup = $$new_props.dropup);
		if ("group" in $$new_props) $$invalidate(6, group = $$new_props.group);
		if ("inNavbar" in $$new_props) $$invalidate(7, inNavbar = $$new_props.inNavbar);
		if ("isOpen" in $$new_props) $$invalidate(8, isOpen = $$new_props.isOpen);
		if ("nav" in $$new_props) $$invalidate(9, nav = $$new_props.nav);
		if ("setActiveFromChild" in $$new_props) $$invalidate(10, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("size" in $$new_props) $$invalidate(11, size = $$new_props.size);
		if ("toggle" in $$new_props) $$invalidate(12, toggle = $$new_props.toggle);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Dropdown,
		className,
		active,
		addonType,
		direction,
		disabled,
		dropup,
		group,
		inNavbar,
		isOpen,
		nav,
		setActiveFromChild,
		size,
		toggle
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(1, active = $$new_props.active);
		if ("addonType" in $$props) $$invalidate(2, addonType = $$new_props.addonType);
		if ("direction" in $$props) $$invalidate(3, direction = $$new_props.direction);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("dropup" in $$props) $$invalidate(5, dropup = $$new_props.dropup);
		if ("group" in $$props) $$invalidate(6, group = $$new_props.group);
		if ("inNavbar" in $$props) $$invalidate(7, inNavbar = $$new_props.inNavbar);
		if ("isOpen" in $$props) $$invalidate(8, isOpen = $$new_props.isOpen);
		if ("nav" in $$props) $$invalidate(9, nav = $$new_props.nav);
		if ("setActiveFromChild" in $$props) $$invalidate(10, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("size" in $$props) $$invalidate(11, size = $$new_props.size);
		if ("toggle" in $$props) $$invalidate(12, toggle = $$new_props.toggle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		active,
		addonType,
		direction,
		disabled,
		dropup,
		group,
		inNavbar,
		isOpen,
		nav,
		setActiveFromChild,
		size,
		toggle,
		$$restProps,
		slots,
		click_handler,
		$$scope
	];
}

class ButtonDropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			class: 0,
			active: 1,
			addonType: 2,
			direction: 3,
			disabled: 4,
			dropup: 5,
			group: 6,
			inNavbar: 7,
			isOpen: 8,
			nav: 9,
			setActiveFromChild: 10,
			size: 11,
			toggle: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ButtonDropdown",
			options,
			id: create_fragment$6.name
		});
	}

	get class() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addonType() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addonType(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropup() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropup(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inNavbar() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inNavbar(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nav() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nav(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setActiveFromChild() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setActiveFromChild(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<ButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<ButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ButtonGroup.svelte generated by Svelte v3.37.0 */
const file$7 = "node_modules/sveltestrap/src/ButtonGroup.svelte";

function create_fragment$7(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$7, 15, 0, 305);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","size","vertical"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ButtonGroup", slots, ['default']);
	let { class: className = "" } = $$props;
	let { size = "" } = $$props;
	let { vertical = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
		if ("vertical" in $$new_props) $$invalidate(4, vertical = $$new_props.vertical);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		size,
		vertical,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("vertical" in $$props) $$invalidate(4, vertical = $$new_props.vertical);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size, vertical*/ 28) {
			$: $$invalidate(0, classes = classnames(className, size ? `btn-group-${size}` : false, vertical ? "btn-group-vertical" : "btn-group"));
		}
	};

	return [classes, $$restProps, className, size, vertical, $$scope, slots];
}

class ButtonGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { class: 2, size: 3, vertical: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ButtonGroup",
			options,
			id: create_fragment$7.name
		});
	}

	get class() {
		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ButtonToolbar.svelte generated by Svelte v3.37.0 */
const file$8 = "node_modules/sveltestrap/src/ButtonToolbar.svelte";

function create_fragment$8(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let div_levels = [
		/*$$restProps*/ ctx[2],
		{ "aria-label": /*ariaLabel*/ ctx[0] },
		{ role: "toolbar" },
		{ class: /*classes*/ ctx[1] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$8, 10, 0, 195);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] },
				{ role: "toolbar" },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ButtonToolbar", slots, ['default']);
	let { class: className = "" } = $$props;
	let { ariaLabel = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("ariaLabel" in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		ariaLabel,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("ariaLabel" in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$: $$invalidate(1, classes = classnames(className, "btn-toolbar"));
		}
	};

	return [ariaLabel, classes, $$restProps, className, $$scope, slots];
}

class ButtonToolbar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { class: 3, ariaLabel: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ButtonToolbar",
			options,
			id: create_fragment$8.name
		});
	}

	get class() {
		throw new Error("<ButtonToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ButtonToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<ButtonToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<ButtonToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Card.svelte generated by Svelte v3.37.0 */
const file$9 = "node_modules/sveltestrap/src/Card.svelte";

function create_fragment$9(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ style: /*style*/ ctx[0] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$9, 20, 0, 437);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*style*/ 1) && { style: /*style*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","body","color","inverse","outline","style"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card", slots, ['default']);
	let { class: className = "" } = $$props;
	let { body = false } = $$props;
	let { color = "" } = $$props;
	let { inverse = false } = $$props;
	let { outline = false } = $$props;
	let { style = "" } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("body" in $$new_props) $$invalidate(4, body = $$new_props.body);
		if ("color" in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ("inverse" in $$new_props) $$invalidate(6, inverse = $$new_props.inverse);
		if ("outline" in $$new_props) $$invalidate(7, outline = $$new_props.outline);
		if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		body,
		color,
		inverse,
		outline,
		style,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("body" in $$props) $$invalidate(4, body = $$new_props.body);
		if ("color" in $$props) $$invalidate(5, color = $$new_props.color);
		if ("inverse" in $$props) $$invalidate(6, inverse = $$new_props.inverse);
		if ("outline" in $$props) $$invalidate(7, outline = $$new_props.outline);
		if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, inverse, body, color, outline*/ 248) {
			$: $$invalidate(1, classes = classnames(className, "card", inverse ? "text-white" : false, body ? "card-body" : false, color ? `${outline ? "border" : "bg"}-${color}` : false));
		}
	};

	return [
		style,
		classes,
		$$restProps,
		className,
		body,
		color,
		inverse,
		outline,
		$$scope,
		slots,
		click_handler
	];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			class: 3,
			body: 4,
			color: 5,
			inverse: 6,
			outline: 7,
			style: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment$9.name
		});
	}

	get class() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get body() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set body(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inverse() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inverse(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardBody.svelte generated by Svelte v3.37.0 */
const file$a = "node_modules/sveltestrap/src/CardBody.svelte";

function create_fragment$a(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$a, 9, 0, 164);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardBody", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-body"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardBody extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardBody",
			options,
			id: create_fragment$a.name
		});
	}

	get class() {
		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardColumns.svelte generated by Svelte v3.37.0 */
const file$b = "node_modules/sveltestrap/src/CardColumns.svelte";

function create_fragment$b(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$b, 9, 0, 167);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardColumns", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-columns"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardColumns extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardColumns",
			options,
			id: create_fragment$b.name
		});
	}

	get class() {
		throw new Error("<CardColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardDeck.svelte generated by Svelte v3.37.0 */
const file$c = "node_modules/sveltestrap/src/CardDeck.svelte";

function create_fragment$c(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$c, 9, 0, 164);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardDeck", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-deck"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardDeck extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardDeck",
			options,
			id: create_fragment$c.name
		});
	}

	get class() {
		throw new Error("<CardDeck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardDeck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardFooter.svelte generated by Svelte v3.37.0 */
const file$d = "node_modules/sveltestrap/src/CardFooter.svelte";

function create_fragment$d(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$d, 9, 0, 166);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardFooter", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-footer"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardFooter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardFooter",
			options,
			id: create_fragment$d.name
		});
	}

	get class() {
		throw new Error("<CardFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardGroup.svelte generated by Svelte v3.37.0 */
const file$e = "node_modules/sveltestrap/src/CardGroup.svelte";

function create_fragment$e(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$e, 9, 0, 165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardGroup", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-group"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardGroup",
			options,
			id: create_fragment$e.name
		});
	}

	get class() {
		throw new Error("<CardGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardHeader.svelte generated by Svelte v3.37.0 */
const file$f = "node_modules/sveltestrap/src/CardHeader.svelte";

// (15:0) {:else}
function create_else_block$6(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$f, 15, 2, 291);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_1*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(15:0) {:else}",
		ctx
	});

	return block;
}

// (11:0) {#if tag === 'h3'}
function create_if_block$6(ctx) {
	let h3;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let h3_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let h3_data = {};

	for (let i = 0; i < h3_levels.length; i += 1) {
		h3_data = assign(h3_data, h3_levels[i]);
	}

	const block = {
		c: function create() {
			h3 = element("h3");
			if (default_slot) default_slot.c();
			set_attributes(h3, h3_data);
			add_location(h3, file$f, 11, 2, 213);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(h3, "click", /*click_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(h3, h3_data = get_spread_update(h3_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(11:0) {#if tag === 'h3'}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "h3") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","tag"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardHeader", slots, ['default']);
	let { class: className = "" } = $$props;
	let { tag = "div" } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, tag, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$: $$invalidate(1, classes = classnames(className, "card-header"));
		}
	};

	return [
		tag,
		classes,
		$$restProps,
		className,
		$$scope,
		slots,
		click_handler,
		click_handler_1
	];
}

class CardHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { class: 3, tag: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardHeader",
			options,
			id: create_fragment$f.name
		});
	}

	get class() {
		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardImg.svelte generated by Svelte v3.37.0 */
const file$g = "node_modules/sveltestrap/src/CardImg.svelte";

function create_fragment$g(ctx) {
	let img;
	let img_src_value;

	let img_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] },
		{ src: img_src_value = /*src*/ ctx[0] },
		{ alt: /*alt*/ ctx[1] }
	];

	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = assign(img_data, img_levels[i]);
	}

	const block = {
		c: function create() {
			img = element("img");
			set_attributes(img, img_data);
			add_location(img, file$g, 23, 0, 464);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, [dirty]) {
			set_attributes(img, img_data = get_spread_update(img_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] },
				dirty & /*src*/ 1 && img.src !== (img_src_value = /*src*/ ctx[0]) && { src: img_src_value },
				dirty & /*alt*/ 2 && { alt: /*alt*/ ctx[1] }
			]));
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","top","bottom","src","alt"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardImg", slots, []);
	let { class: className = "" } = $$props;
	let { top = false } = $$props;
	let { bottom = false } = $$props;
	let { src } = $$props;
	let { alt = "" } = $$props;
	let classes = "";

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("top" in $$new_props) $$invalidate(5, top = $$new_props.top);
		if ("bottom" in $$new_props) $$invalidate(6, bottom = $$new_props.bottom);
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		top,
		bottom,
		src,
		alt,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("top" in $$props) $$invalidate(5, top = $$new_props.top);
		if ("bottom" in $$props) $$invalidate(6, bottom = $$new_props.bottom);
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*top, bottom, className*/ 112) {
			$: {
				let cardImgClassName = "card-img";

				if (top) {
					cardImgClassName = "card-img-top";
				}

				if (bottom) {
					cardImgClassName = "card-img-bottom";
				}

				$$invalidate(2, classes = classnames(className, cardImgClassName));
			}
		}
	};

	return [src, alt, classes, $$restProps, className, top, bottom];
}

class CardImg extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			class: 4,
			top: 5,
			bottom: 6,
			src: 0,
			alt: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardImg",
			options,
			id: create_fragment$g.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<CardImg> was created without expected prop 'src'");
		}
	}

	get class() {
		throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get src() {
		throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardImgOverlay.svelte generated by Svelte v3.37.0 */
const file$h = "node_modules/sveltestrap/src/CardImgOverlay.svelte";

function create_fragment$h(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$h, 9, 0, 171);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardImgOverlay", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-img-overlay"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardImgOverlay extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardImgOverlay",
			options,
			id: create_fragment$h.name
		});
	}

	get class() {
		throw new Error("<CardImgOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardImgOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardLink.svelte generated by Svelte v3.37.0 */
const file$i = "node_modules/sveltestrap/src/CardLink.svelte";

function create_fragment$i(ctx) {
	let a;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let a_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ href: /*href*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$i, 10, 0, 188);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","href"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardLink", slots, ['default']);
	let { class: className = "" } = $$props;
	let { href = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, href, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$: $$invalidate(1, classes = classnames(className, "card-link"));
		}
	};

	return [href, classes, $$restProps, className, $$scope, slots];
}

class CardLink extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { class: 3, href: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardLink",
			options,
			id: create_fragment$i.name
		});
	}

	get class() {
		throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardSubtitle.svelte generated by Svelte v3.37.0 */
const file$j = "node_modules/sveltestrap/src/CardSubtitle.svelte";

function create_fragment$j(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$j, 9, 0, 168);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardSubtitle", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-subtitle"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardSubtitle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardSubtitle",
			options,
			id: create_fragment$j.name
		});
	}

	get class() {
		throw new Error("<CardSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardText.svelte generated by Svelte v3.37.0 */
const file$k = "node_modules/sveltestrap/src/CardText.svelte";

function create_fragment$k(ctx) {
	let p;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let p_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	const block = {
		c: function create() {
			p = element("p");
			if (default_slot) default_slot.c();
			set_attributes(p, p_data);
			add_location(p, file$k, 9, 0, 164);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardText", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-text"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardText extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardText",
			options,
			id: create_fragment$k.name
		});
	}

	get class() {
		throw new Error("<CardText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CardTitle.svelte generated by Svelte v3.37.0 */
const file$l = "node_modules/sveltestrap/src/CardTitle.svelte";

function create_fragment$l(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$l, 9, 0, 165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CardTitle", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "card-title"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class CardTitle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CardTitle",
			options,
			id: create_fragment$l.name
		});
	}

	get class() {
		throw new Error("<CardTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CardTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Carousel.svelte generated by Svelte v3.37.0 */
const file$m = "node_modules/sveltestrap/src/Carousel.svelte";

function create_fragment$m(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let div_levels = [
		/*$$restProps*/ ctx[6],
		{ class: /*classes*/ ctx[2] },
		{ style: /*style*/ ctx[0] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$m, 85, 0, 1813);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*handleKeydown*/ ctx[3], false, false, false),
					listen_dev(div, "mouseenter", /*mouseenter_handler*/ ctx[15], false, false, false),
					listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*style*/ 1) && { style: /*style*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","style","items","activeIndex","ride","interval","pause","keyboard"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Carousel", slots, ['default']);
	let classes = "";
	let { class: className = "" } = $$props;
	let { style = "" } = $$props;
	let { items = [] } = $$props;
	let { activeIndex = 0 } = $$props;
	let { ride = true } = $$props;
	let { interval = 5000 } = $$props;
	let { pause = true } = $$props;
	let { keyboard = true } = $$props;
	let _rideTimeoutId = false;
	let _removeVisibilityChangeListener = false;

	onMount(() => {
		setRideTimeout();

		_removeVisibilityChangeListener = browserEvent(document, "visibilitychange", () => {
			if (document.visibilityState === "hidden") {
				clearRideTimeout();
			} else {
				setRideTimeout();
			}
		});
	});

	onDestroy(() => {
		if (_rideTimeoutId) {
			clearTimeout(_rideTimeoutId);
		}

		if (_removeVisibilityChangeListener) {
			_removeVisibilityChangeListener();
		}
	});

	function handleKeydown(event) {
		if (!keyboard) {
			return;
		}

		let direction = "";

		if (event.key === "ArrowLeft") {
			direction = "prev";
		} else if (event.key === "ArrowRight") {
			direction = "next";
		} else {
			return;
		}

		$$invalidate(7, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
	}

	function setRideTimeout() {
		clearRideTimeout();

		if (ride) {
			_rideTimeoutId = setTimeout(autoNext, interval);
		}
	}

	function clearRideTimeout() {
		if (_rideTimeoutId) {
			clearTimeout(_rideTimeoutId);
		}
	}

	function autoNext() {
		$$invalidate(7, activeIndex = getNewCarouselActiveIndex("next", items, activeIndex));
	}

	const mouseenter_handler = () => pause ? clearRideTimeout() : undefined;
	const mouseleave_handler = () => pause ? setRideTimeout() : undefined;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
		if ("items" in $$new_props) $$invalidate(9, items = $$new_props.items);
		if ("activeIndex" in $$new_props) $$invalidate(7, activeIndex = $$new_props.activeIndex);
		if ("ride" in $$new_props) $$invalidate(10, ride = $$new_props.ride);
		if ("interval" in $$new_props) $$invalidate(11, interval = $$new_props.interval);
		if ("pause" in $$new_props) $$invalidate(1, pause = $$new_props.pause);
		if ("keyboard" in $$new_props) $$invalidate(12, keyboard = $$new_props.keyboard);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onDestroy,
		onMount,
		classnames,
		getNewCarouselActiveIndex,
		browserEvent,
		classes,
		className,
		style,
		items,
		activeIndex,
		ride,
		interval,
		pause,
		keyboard,
		_rideTimeoutId,
		_removeVisibilityChangeListener,
		handleKeydown,
		setRideTimeout,
		clearRideTimeout,
		autoNext
	});

	$$self.$inject_state = $$new_props => {
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
		if ("items" in $$props) $$invalidate(9, items = $$new_props.items);
		if ("activeIndex" in $$props) $$invalidate(7, activeIndex = $$new_props.activeIndex);
		if ("ride" in $$props) $$invalidate(10, ride = $$new_props.ride);
		if ("interval" in $$props) $$invalidate(11, interval = $$new_props.interval);
		if ("pause" in $$props) $$invalidate(1, pause = $$new_props.pause);
		if ("keyboard" in $$props) $$invalidate(12, keyboard = $$new_props.keyboard);
		if ("_rideTimeoutId" in $$props) _rideTimeoutId = $$new_props._rideTimeoutId;
		if ("_removeVisibilityChangeListener" in $$props) _removeVisibilityChangeListener = $$new_props._removeVisibilityChangeListener;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 256) {
			$: $$invalidate(2, classes = classnames(className, "carousel", "slide"));
		}
	};

	return [
		style,
		pause,
		classes,
		handleKeydown,
		setRideTimeout,
		clearRideTimeout,
		$$restProps,
		activeIndex,
		className,
		items,
		ride,
		interval,
		keyboard,
		$$scope,
		slots,
		mouseenter_handler,
		mouseleave_handler
	];
}

class Carousel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			class: 8,
			style: 0,
			items: 9,
			activeIndex: 7,
			ride: 10,
			interval: 11,
			pause: 1,
			keyboard: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Carousel",
			options,
			id: create_fragment$m.name
		});
	}

	get class() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeIndex() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeIndex(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ride() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ride(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get interval() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set interval(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pause() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pause(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyboard() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyboard(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CarouselControl.svelte generated by Svelte v3.37.0 */
const file$n = "node_modules/sveltestrap/src/CarouselControl.svelte";

function create_fragment$n(ctx) {
	let a;
	let span0;
	let span0_class_value;
	let t0;
	let span1;
	let t1;
	let a_href_value;
	let mounted;
	let dispose;

	let a_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[1] },
		{ role: "button" },
		{
			href: a_href_value = "#" + /*direction*/ ctx[0]
		}
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = text(/*srText*/ ctx[2]);
			attr_dev(span0, "class", span0_class_value = "carousel-control-" + /*direction*/ ctx[0] + "-icon");
			attr_dev(span0, "aria-hidden", "true");
			add_location(span0, file$n, 45, 2, 1098);
			attr_dev(span1, "class", "sr-only");
			add_location(span1, file$n, 46, 2, 1170);
			set_attributes(a, a_data);
			add_location(a, file$n, 39, 0, 976);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, span0);
			append_dev(a, t0);
			append_dev(a, span1);
			append_dev(span1, t1);

			if (!mounted) {
				dispose = listen_dev(a, "click", prevent_default(/*clickHandler*/ ctx[3]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*direction*/ 1 && span0_class_value !== (span0_class_value = "carousel-control-" + /*direction*/ ctx[0] + "-icon")) {
				attr_dev(span0, "class", span0_class_value);
			}

			if (dirty & /*srText*/ 4) set_data_dev(t1, /*srText*/ ctx[2]);

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
				{ role: "button" },
				dirty & /*direction*/ 1 && a_href_value !== (a_href_value = "#" + /*direction*/ ctx[0]) && { href: a_href_value }
			]));
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","direction","directionText","activeIndex","items","wrap"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CarouselControl", slots, []);
	let classes = "";
	let { class: className = "" } = $$props;
	let srText = "";
	let { direction = "" } = $$props;
	let { directionText = "" } = $$props;
	let { activeIndex = 0 } = $$props;
	let { items = [] } = $$props;
	let { wrap = true } = $$props;

	const getSrText = direction => {
		if (direction === "next") {
			return "Next";
		} else if (direction === "prev") {
			return "Previous";
		}
	};

	function clickHandler() {
		const endOrBeginning = direction === "next" && activeIndex + 1 > items.length - 1 || direction === "previous" && activeIndex - 1 < 0;

		if (!wrap && endOrBeginning) {
			return;
		}

		$$invalidate(5, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("direction" in $$new_props) $$invalidate(0, direction = $$new_props.direction);
		if ("directionText" in $$new_props) $$invalidate(7, directionText = $$new_props.directionText);
		if ("activeIndex" in $$new_props) $$invalidate(5, activeIndex = $$new_props.activeIndex);
		if ("items" in $$new_props) $$invalidate(8, items = $$new_props.items);
		if ("wrap" in $$new_props) $$invalidate(9, wrap = $$new_props.wrap);
	};

	$$self.$capture_state = () => ({
		classnames,
		getNewCarouselActiveIndex,
		classes,
		className,
		srText,
		direction,
		directionText,
		activeIndex,
		items,
		wrap,
		getSrText,
		clickHandler
	});

	$$self.$inject_state = $$new_props => {
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("srText" in $$props) $$invalidate(2, srText = $$new_props.srText);
		if ("direction" in $$props) $$invalidate(0, direction = $$new_props.direction);
		if ("directionText" in $$props) $$invalidate(7, directionText = $$new_props.directionText);
		if ("activeIndex" in $$props) $$invalidate(5, activeIndex = $$new_props.activeIndex);
		if ("items" in $$props) $$invalidate(8, items = $$new_props.items);
		if ("wrap" in $$props) $$invalidate(9, wrap = $$new_props.wrap);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*direction, className*/ 65) {
			$: $$invalidate(1, classes = classnames(`carousel-control-${direction}`, className));
		}

		if ($$self.$$.dirty & /*directionText, direction*/ 129) {
			$: $$invalidate(2, srText = directionText ? directionText : getSrText(direction));
		}
	};

	return [
		direction,
		classes,
		srText,
		clickHandler,
		$$restProps,
		activeIndex,
		className,
		directionText,
		items,
		wrap
	];
}

class CarouselControl extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			class: 6,
			direction: 0,
			directionText: 7,
			activeIndex: 5,
			items: 8,
			wrap: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CarouselControl",
			options,
			id: create_fragment$n.name
		});
	}

	get class() {
		throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get directionText() {
		throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set directionText(value) {
		throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeIndex() {
		throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeIndex(value) {
		throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrap() {
		throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrap(value) {
		throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CarouselIndicators.svelte generated by Svelte v3.37.0 */
const file$o = "node_modules/sveltestrap/src/CarouselIndicators.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	child_ctx[8] = i;
	return child_ctx;
}

// (14:2) {#each items as _item, index}
function create_each_block(ctx) {
	let li;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[5](/*index*/ ctx[8]);
	}

	const block = {
		c: function create() {
			li = element("li");
			toggle_class(li, "active", /*activeIndex*/ ctx[0] === /*index*/ ctx[8]);
			add_location(li, file$o, 14, 4, 323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*activeIndex*/ 1) {
				toggle_class(li, "active", /*activeIndex*/ ctx[0] === /*index*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(14:2) {#each items as _item, index}",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let ol;
	let each_value = /*items*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let ol_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let ol_data = {};

	for (let i = 0; i < ol_levels.length; i += 1) {
		ol_data = assign(ol_data, ol_levels[i]);
	}

	const block = {
		c: function create() {
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			set_attributes(ol, ol_data);
			add_location(ol, file$o, 12, 0, 249);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, ol, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*activeIndex, items*/ 3) {
				each_value = /*items*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			set_attributes(ol, ol_data = get_spread_update(ol_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] }
			]));
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(ol);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","items","activeIndex"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CarouselIndicators", slots, []);
	let { class: className = "" } = $$props;
	let classes = "";
	let { items = [] } = $$props;
	let { activeIndex = 0 } = $$props;
	const click_handler = index => $$invalidate(0, activeIndex = index);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("items" in $$new_props) $$invalidate(1, items = $$new_props.items);
		if ("activeIndex" in $$new_props) $$invalidate(0, activeIndex = $$new_props.activeIndex);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		classes,
		items,
		activeIndex
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
		if ("items" in $$props) $$invalidate(1, items = $$new_props.items);
		if ("activeIndex" in $$props) $$invalidate(0, activeIndex = $$new_props.activeIndex);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$: $$invalidate(2, classes = classnames(className, "carousel-indicators"));
		}
	};

	return [activeIndex, items, classes, $$restProps, className, click_handler];
}

class CarouselIndicators extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$o, safe_not_equal, { class: 4, items: 1, activeIndex: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CarouselIndicators",
			options,
			id: create_fragment$o.name
		});
	}

	get class() {
		throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeIndex() {
		throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeIndex(value) {
		throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CarouselItem.svelte generated by Svelte v3.37.0 */
const file$p = "node_modules/sveltestrap/src/CarouselItem.svelte";

function create_fragment$p(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	let div_levels = [
		/*$$restProps*/ ctx[3],
		{
			class: div_class_value = "" + (/*classes*/ ctx[2] + " active")
		}
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			toggle_class(div, "active", /*itemIndex*/ ctx[0] === /*activeIndex*/ ctx[1]);
			add_location(div, file$p, 12, 0, 246);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4 && div_class_value !== (div_class_value = "" + (/*classes*/ ctx[2] + " active"))) && { class: div_class_value }
			]));

			toggle_class(div, "active", /*itemIndex*/ ctx[0] === /*activeIndex*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","itemIndex","activeIndex"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CarouselItem", slots, ['default']);
	let classes = "";
	let { class: className = "" } = $$props;
	let { itemIndex = 0 } = $$props;
	let { activeIndex = 0 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("itemIndex" in $$new_props) $$invalidate(0, itemIndex = $$new_props.itemIndex);
		if ("activeIndex" in $$new_props) $$invalidate(1, activeIndex = $$new_props.activeIndex);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		classes,
		className,
		itemIndex,
		activeIndex
	});

	$$self.$inject_state = $$new_props => {
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("itemIndex" in $$props) $$invalidate(0, itemIndex = $$new_props.itemIndex);
		if ("activeIndex" in $$props) $$invalidate(1, activeIndex = $$new_props.activeIndex);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$: $$invalidate(2, classes = classnames(className, "carousel-item"));
		}
	};

	return [itemIndex, activeIndex, classes, $$restProps, className, $$scope, slots];
}

class CarouselItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$p, safe_not_equal, { class: 4, itemIndex: 0, activeIndex: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CarouselItem",
			options,
			id: create_fragment$p.name
		});
	}

	get class() {
		throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemIndex() {
		throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemIndex(value) {
		throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeIndex() {
		throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeIndex(value) {
		throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CarouselCaption.svelte generated by Svelte v3.37.0 */
const file$q = "node_modules/sveltestrap/src/CarouselCaption.svelte";

function create_fragment$q(ctx) {
	let div;
	let h5;
	let t0;
	let t1;
	let p;
	let t2;
	let t3;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			h5 = element("h5");
			t0 = text(/*captionHeader*/ ctx[0]);
			t1 = space();
			p = element("p");
			t2 = text(/*captionText*/ ctx[1]);
			t3 = space();
			if (default_slot) default_slot.c();
			add_location(h5, file$q, 18, 2, 340);
			add_location(p, file$q, 19, 2, 367);
			set_attributes(div, div_data);
			add_location(div, file$q, 17, 0, 299);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h5);
			append_dev(h5, t0);
			append_dev(div, t1);
			append_dev(div, p);
			append_dev(p, t2);
			append_dev(div, t3);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*captionHeader*/ 1) set_data_dev(t0, /*captionHeader*/ ctx[0]);
			if (!current || dirty & /*captionText*/ 2) set_data_dev(t2, /*captionText*/ ctx[1]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","captionHeader","captionText"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CarouselCaption", slots, ['default']);
	let classes = "";
	let { class: className = "" } = $$props;
	let { captionHeader = "" } = $$props;
	let { captionText = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("captionHeader" in $$new_props) $$invalidate(0, captionHeader = $$new_props.captionHeader);
		if ("captionText" in $$new_props) $$invalidate(1, captionText = $$new_props.captionText);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		classes,
		className,
		captionHeader,
		captionText
	});

	$$self.$inject_state = $$new_props => {
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("captionHeader" in $$props) $$invalidate(0, captionHeader = $$new_props.captionHeader);
		if ("captionText" in $$props) $$invalidate(1, captionText = $$new_props.captionText);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$: $$invalidate(2, classes = classnames(className, "carousel-caption", "d-none", "d-md-block"));
		}
	};

	return [captionHeader, captionText, classes, $$restProps, className, $$scope, slots];
}

class CarouselCaption extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
			class: 4,
			captionHeader: 0,
			captionText: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CarouselCaption",
			options,
			id: create_fragment$q.name
		});
	}

	get class() {
		throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get captionHeader() {
		throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set captionHeader(value) {
		throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get captionText() {
		throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set captionText(value) {
		throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Col.svelte generated by Svelte v3.37.0 */
const file$r = "node_modules/sveltestrap/src/Col.svelte";

function create_fragment$r(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		/*$$restProps*/ ctx[1],
		{
			class: div_class_value = /*colClasses*/ ctx[0].join(" ")
		}
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$r, 58, 0, 1388);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				{ class: div_class_value }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","xs","sm","md","lg","xl"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Col", slots, ['default']);
	let { class: className = "" } = $$props;
	let { xs = undefined } = $$props;
	let { sm = undefined } = $$props;
	let { md = undefined } = $$props;
	let { lg = undefined } = $$props;
	let { xl = undefined } = $$props;
	const colClasses = [];
	const lookup = { xs, sm, md, lg, xl };

	Object.keys(lookup).forEach(colWidth => {
		const columnProp = lookup[colWidth];

		if (!columnProp && columnProp !== "") {
			return; //no value for this width
		}

		const isXs = colWidth === "xs";

		if (isObject(columnProp)) {
			const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
			const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

			if (columnProp.size || columnProp.size === "") {
				colClasses.push(colClass);
			}

			if (columnProp.push) {
				colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
			}

			if (columnProp.pull) {
				colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
			}

			if (columnProp.offset) {
				colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
			}
		} else {
			colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
		}
	});

	if (!colClasses.length) {
		colClasses.push("col");
	}

	if (className) {
		colClasses.push(className);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("xs" in $$new_props) $$invalidate(3, xs = $$new_props.xs);
		if ("sm" in $$new_props) $$invalidate(4, sm = $$new_props.sm);
		if ("md" in $$new_props) $$invalidate(5, md = $$new_props.md);
		if ("lg" in $$new_props) $$invalidate(6, lg = $$new_props.lg);
		if ("xl" in $$new_props) $$invalidate(7, xl = $$new_props.xl);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getColumnSizeClass,
		isObject,
		className,
		xs,
		sm,
		md,
		lg,
		xl,
		colClasses,
		lookup
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("xs" in $$props) $$invalidate(3, xs = $$new_props.xs);
		if ("sm" in $$props) $$invalidate(4, sm = $$new_props.sm);
		if ("md" in $$props) $$invalidate(5, md = $$new_props.md);
		if ("lg" in $$props) $$invalidate(6, lg = $$new_props.lg);
		if ("xl" in $$props) $$invalidate(7, xl = $$new_props.xl);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [colClasses, $$restProps, className, xs, sm, md, lg, xl, $$scope, slots];
}

class Col extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
			class: 2,
			xs: 3,
			sm: 4,
			md: 5,
			lg: 6,
			xl: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Col",
			options,
			id: create_fragment$r.name
		});
	}

	get class() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xs() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xs(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sm() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sm(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get md() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set md(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lg() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lg(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xl() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xl(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Collapse.svelte generated by Svelte v3.37.0 */
const file$s = "node_modules/sveltestrap/src/Collapse.svelte";

// (57:0) {#if isOpen}
function create_if_block$7(ctx) {
	let div;
	let div_style_value;
	let div_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let div_levels = [
		{
			style: div_style_value = /*navbar*/ ctx[1] ? undefined : "overflow: hidden;"
		},
		/*$$restProps*/ ctx[8],
		{ class: /*classes*/ ctx[7] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$s, 57, 2, 1231);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "introstart", /*introstart_handler*/ ctx[15], false, false, false),
					listen_dev(div, "introend", /*introend_handler*/ ctx[16], false, false, false),
					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[17], false, false, false),
					listen_dev(div, "outroend", /*outroend_handler*/ ctx[18], false, false, false),
					listen_dev(
						div,
						"introstart",
						function () {
							if (is_function(/*onEntering*/ ctx[2])) /*onEntering*/ ctx[2].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div,
						"introend",
						function () {
							if (is_function(/*onEntered*/ ctx[3])) /*onEntered*/ ctx[3].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div,
						"outrostart",
						function () {
							if (is_function(/*onExiting*/ ctx[4])) /*onExiting*/ ctx[4].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div,
						"outroend",
						function () {
							if (is_function(/*onExited*/ ctx[5])) /*onExited*/ ctx[5].apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*navbar*/ 2 && div_style_value !== (div_style_value = /*navbar*/ ctx[1] ? undefined : "overflow: hidden;")) && { style: div_style_value },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (local) {
				add_render_callback(() => {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(57:0) {#if isOpen}",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[19]);
	let if_block = /*isOpen*/ ctx[0] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[19]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"isOpen","class","navbar","onEntering","onEntered","onExiting","onExited","expand"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Collapse", slots, ['default']);
	const noop = () => undefined;
	let { isOpen = false } = $$props;
	let { class: className = "" } = $$props;
	let { navbar = false } = $$props;
	let { onEntering = noop } = $$props;
	let { onEntered = noop } = $$props;
	let { onExiting = noop } = $$props;
	let { onExited = noop } = $$props;
	let { expand = false } = $$props;
	let windowWidth = 0;
	let _wasMaximazed = false;
	const minWidth = {};
	minWidth["xs"] = 0;
	minWidth["sm"] = 576;
	minWidth["md"] = 768;
	minWidth["lg"] = 992;
	minWidth["xl"] = 1200;
	const dispatch = createEventDispatcher();

	function notify() {
		dispatch("update", { isOpen });
	}

	function introstart_handler(event) {
		bubble($$self, event);
	}

	function introend_handler(event) {
		bubble($$self, event);
	}

	function outrostart_handler(event) {
		bubble($$self, event);
	}

	function outroend_handler(event) {
		bubble($$self, event);
	}

	function onwindowresize() {
		$$invalidate(6, windowWidth = window.innerWidth);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ("navbar" in $$new_props) $$invalidate(1, navbar = $$new_props.navbar);
		if ("onEntering" in $$new_props) $$invalidate(2, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$new_props) $$invalidate(3, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$new_props) $$invalidate(4, onExiting = $$new_props.onExiting);
		if ("onExited" in $$new_props) $$invalidate(5, onExited = $$new_props.onExited);
		if ("expand" in $$new_props) $$invalidate(10, expand = $$new_props.expand);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		createEventDispatcher,
		slide,
		noop,
		isOpen,
		className,
		navbar,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		expand,
		windowWidth,
		_wasMaximazed,
		minWidth,
		dispatch,
		notify,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
		if ("navbar" in $$props) $$invalidate(1, navbar = $$new_props.navbar);
		if ("onEntering" in $$props) $$invalidate(2, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$props) $$invalidate(3, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$props) $$invalidate(4, onExiting = $$new_props.onExiting);
		if ("onExited" in $$props) $$invalidate(5, onExited = $$new_props.onExited);
		if ("expand" in $$props) $$invalidate(10, expand = $$new_props.expand);
		if ("windowWidth" in $$props) $$invalidate(6, windowWidth = $$new_props.windowWidth);
		if ("_wasMaximazed" in $$props) $$invalidate(11, _wasMaximazed = $$new_props._wasMaximazed);
		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, navbar*/ 514) {
			$: $$invalidate(7, classes = classnames(className, // collapseClass,
			navbar && "navbar-collapse"));
		}

		if ($$self.$$.dirty & /*navbar, expand, windowWidth, minWidth, isOpen, _wasMaximazed*/ 7235) {
			$: if (navbar && expand) {
				if (windowWidth >= minWidth[expand] && !isOpen) {
					$$invalidate(0, isOpen = true);
					$$invalidate(11, _wasMaximazed = true);
					notify();
				} else if (windowWidth < minWidth[expand] && _wasMaximazed) {
					$$invalidate(0, isOpen = false);
					$$invalidate(11, _wasMaximazed = false);
					notify();
				}
			}
		}
	};

	return [
		isOpen,
		navbar,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		windowWidth,
		classes,
		$$restProps,
		className,
		expand,
		_wasMaximazed,
		minWidth,
		$$scope,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler,
		onwindowresize
	];
}

class Collapse extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
			isOpen: 0,
			class: 9,
			navbar: 1,
			onEntering: 2,
			onEntered: 3,
			onExiting: 4,
			onExited: 5,
			expand: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Collapse",
			options,
			id: create_fragment$s.name
		});
	}

	get isOpen() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbar() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbar(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntering() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntering(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntered() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntered(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExiting() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExiting(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExited() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExited(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expand() {
		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expand(value) {
		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Container.svelte generated by Svelte v3.37.0 */
const file$t = "node_modules/sveltestrap/src/Container.svelte";

function create_fragment$t(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$t, 10, 0, 220);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","fluid"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Container", slots, ['default']);
	let { class: className = "" } = $$props;
	let { fluid = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("fluid" in $$new_props) $$invalidate(3, fluid = $$new_props.fluid);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, fluid, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("fluid" in $$props) $$invalidate(3, fluid = $$new_props.fluid);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, fluid*/ 12) {
			$: $$invalidate(0, classes = classnames(className, fluid ? "container-fluid" : "container"));
		}
	};

	return [classes, $$restProps, className, fluid, $$scope, slots];
}

class Container extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$t, create_fragment$t, safe_not_equal, { class: 2, fluid: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Container",
			options,
			id: create_fragment$t.name
		});
	}

	get class() {
		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fluid() {
		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fluid(value) {
		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/CustomInput.svelte generated by Svelte v3.37.0 */
const file$u = "node_modules/sveltestrap/src/CustomInput.svelte";

// (116:0) {:else}
function create_else_block$7(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[14],
		{ type: /*type*/ ctx[4] },
		{ id: /*id*/ ctx[3] },
		{ class: /*combinedClasses*/ ctx[9] },
		{ name: /*name*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[6] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$u, 116, 2, 2501);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_4*/ ctx[40], false, false, false),
					listen_dev(input, "focus", /*focus_handler_4*/ ctx[41], false, false, false),
					listen_dev(input, "change", /*change_handler_4*/ ctx[42], false, false, false),
					listen_dev(input, "input", /*input_handler_4*/ ctx[43], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				dirty[0] & /*type*/ 16 && { type: /*type*/ ctx[4] },
				dirty[0] & /*id*/ 8 && { id: /*id*/ ctx[3] },
				dirty[0] & /*combinedClasses*/ 512 && { class: /*combinedClasses*/ ctx[9] },
				dirty[0] & /*name*/ 4 && { name: /*name*/ ctx[2] },
				dirty[0] & /*disabled*/ 64 && { disabled: /*disabled*/ ctx[6] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(116:0) {:else}",
		ctx
	});

	return block;
}

// (99:27) 
function create_if_block_3$1(ctx) {
	let div;
	let input;
	let t0;
	let label_1;
	let t1;
	let t2;
	let current;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[14],
		{ id: /*id*/ ctx[3] },
		{ type: "radio" },
		{ class: /*customControlClasses*/ ctx[12] },
		{ name: /*name*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[6] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const default_slot_template = /*#slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			label_1 = element("label");
			t1 = text(/*label*/ ctx[5]);
			t2 = space();
			if (default_slot) default_slot.c();
			set_attributes(input, input_data);
			add_location(input, file$u, 100, 4, 2186);
			attr_dev(label_1, "class", "custom-control-label");
			attr_dev(label_1, "for", /*labelHtmlFor*/ ctx[13]);
			add_location(label_1, file$u, 112, 4, 2398);
			attr_dev(div, "class", /*wrapperClasses*/ ctx[11]);
			add_location(div, file$u, 99, 2, 2153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t0);
			append_dev(div, label_1);
			append_dev(label_1, t1);
			append_dev(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_3*/ ctx[36], false, false, false),
					listen_dev(input, "focus", /*focus_handler_3*/ ctx[37], false, false, false),
					listen_dev(input, "change", /*change_handler_3*/ ctx[38], false, false, false),
					listen_dev(input, "input", /*input_handler_3*/ ctx[39], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty[0] & /*id*/ 8) && { id: /*id*/ ctx[3] },
				{ type: "radio" },
				(!current || dirty[0] & /*customControlClasses*/ 4096) && { class: /*customControlClasses*/ ctx[12] },
				(!current || dirty[0] & /*name*/ 4) && { name: /*name*/ ctx[2] },
				(!current || dirty[0] & /*disabled*/ 64) && { disabled: /*disabled*/ ctx[6] },
				(!current || dirty[0] & /*placeholder*/ 128) && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (!current || dirty[0] & /*label*/ 32) set_data_dev(t1, /*label*/ ctx[5]);

			if (!current || dirty[0] & /*labelHtmlFor*/ 8192) {
				attr_dev(label_1, "for", /*labelHtmlFor*/ ctx[13]);
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*wrapperClasses*/ 2048) {
				attr_dev(div, "class", /*wrapperClasses*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(99:27) ",
		ctx
	});

	return block;
}

// (81:51) 
function create_if_block_2$3(ctx) {
	let div;
	let input;
	let t0;
	let label_1;
	let t1;
	let t2;
	let current;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[14],
		{ id: /*id*/ ctx[3] },
		{ type: "checkbox" },
		{ class: /*customControlClasses*/ ctx[12] },
		{ name: /*name*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[6] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const default_slot_template = /*#slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			label_1 = element("label");
			t1 = text(/*label*/ ctx[5]);
			t2 = space();
			if (default_slot) default_slot.c();
			set_attributes(input, input_data);
			add_location(input, file$u, 82, 4, 1796);
			attr_dev(label_1, "class", "custom-control-label");
			attr_dev(label_1, "for", /*labelHtmlFor*/ ctx[13]);
			add_location(label_1, file$u, 95, 4, 2030);
			attr_dev(div, "class", /*wrapperClasses*/ ctx[11]);
			add_location(div, file$u, 81, 2, 1763);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			input.checked = /*checked*/ ctx[0];
			append_dev(div, t0);
			append_dev(div, label_1);
			append_dev(label_1, t1);
			append_dev(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[45]),
					listen_dev(input, "blur", /*blur_handler_2*/ ctx[32], false, false, false),
					listen_dev(input, "focus", /*focus_handler_2*/ ctx[33], false, false, false),
					listen_dev(input, "change", /*change_handler_2*/ ctx[34], false, false, false),
					listen_dev(input, "input", /*input_handler_2*/ ctx[35], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty[0] & /*id*/ 8) && { id: /*id*/ ctx[3] },
				{ type: "checkbox" },
				(!current || dirty[0] & /*customControlClasses*/ 4096) && { class: /*customControlClasses*/ ctx[12] },
				(!current || dirty[0] & /*name*/ 4) && { name: /*name*/ ctx[2] },
				(!current || dirty[0] & /*disabled*/ 64) && { disabled: /*disabled*/ ctx[6] },
				(!current || dirty[0] & /*placeholder*/ 128) && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (!current || dirty[0] & /*label*/ 32) set_data_dev(t1, /*label*/ ctx[5]);

			if (!current || dirty[0] & /*labelHtmlFor*/ 8192) {
				attr_dev(label_1, "for", /*labelHtmlFor*/ ctx[13]);
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*wrapperClasses*/ 2048) {
				attr_dev(div, "class", /*wrapperClasses*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(81:51) ",
		ctx
	});

	return block;
}

// (63:26) 
function create_if_block_1$3(ctx) {
	let div;
	let input;
	let t0;
	let label_1;
	let t1_value = (/*label*/ ctx[5] || "Choose file") + "";
	let t1;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[14],
		{ id: /*id*/ ctx[3] },
		{ type: "file" },
		{ class: /*fileClasses*/ ctx[10] },
		{ name: /*name*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[6] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			label_1 = element("label");
			t1 = text(t1_value);
			set_attributes(input, input_data);
			add_location(input, file$u, 64, 4, 1401);
			attr_dev(label_1, "class", "custom-file-label");
			attr_dev(label_1, "for", /*labelHtmlFor*/ ctx[13]);
			add_location(label_1, file$u, 76, 4, 1603);
			attr_dev(div, "class", /*customClass*/ ctx[8]);
			add_location(div, file$u, 63, 2, 1371);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t0);
			append_dev(div, label_1);
			append_dev(label_1, t1);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[28], false, false, false),
					listen_dev(input, "focus", /*focus_handler_1*/ ctx[29], false, false, false),
					listen_dev(input, "change", /*change_handler_1*/ ctx[30], false, false, false),
					listen_dev(input, "input", /*input_handler_1*/ ctx[31], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				dirty[0] & /*id*/ 8 && { id: /*id*/ ctx[3] },
				{ type: "file" },
				dirty[0] & /*fileClasses*/ 1024 && { class: /*fileClasses*/ ctx[10] },
				dirty[0] & /*name*/ 4 && { name: /*name*/ ctx[2] },
				dirty[0] & /*disabled*/ 64 && { disabled: /*disabled*/ ctx[6] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*label*/ 32 && t1_value !== (t1_value = (/*label*/ ctx[5] || "Choose file") + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*labelHtmlFor*/ 8192) {
				attr_dev(label_1, "for", /*labelHtmlFor*/ ctx[13]);
			}

			if (dirty[0] & /*customClass*/ 256) {
				attr_dev(div, "class", /*customClass*/ ctx[8]);
			}
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(63:26) ",
		ctx
	});

	return block;
}

// (48:0) {#if type === 'select'}
function create_if_block$8(ctx) {
	let select;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);

	let select_levels = [
		/*$$restProps*/ ctx[14],
		{ id: /*id*/ ctx[3] },
		{ class: /*combinedClasses*/ ctx[9] },
		{ name: /*name*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[6] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let select_data = {};

	for (let i = 0; i < select_levels.length; i += 1) {
		select_data = assign(select_data, select_levels[i]);
	}

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			set_attributes(select, select_data);
			if (/*value*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[44].call(select));
			add_location(select, file$u, 48, 2, 1139);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			if (select_data.multiple) select_options(select, select_data.value);
			select_option(select, /*value*/ ctx[1]);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "blur", /*blur_handler*/ ctx[24], false, false, false),
					listen_dev(select, "focus", /*focus_handler*/ ctx[25], false, false, false),
					listen_dev(select, "change", /*change_handler*/ ctx[26], false, false, false),
					listen_dev(select, "input", /*input_handler*/ ctx[27], false, false, false),
					listen_dev(select, "change", /*select_change_handler*/ ctx[44])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}

			set_attributes(select, select_data = get_spread_update(select_levels, [
				dirty[0] & /*$$restProps*/ 16384 && /*$$restProps*/ ctx[14],
				(!current || dirty[0] & /*id*/ 8) && { id: /*id*/ ctx[3] },
				(!current || dirty[0] & /*combinedClasses*/ 512) && { class: /*combinedClasses*/ ctx[9] },
				(!current || dirty[0] & /*name*/ 4) && { name: /*name*/ ctx[2] },
				(!current || dirty[0] & /*disabled*/ 64) && { disabled: /*disabled*/ ctx[6] },
				(!current || dirty[0] & /*placeholder*/ 128) && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*$$restProps, id, combinedClasses, name, disabled, placeholder*/ 17100 && select_data.multiple) select_options(select, select_data.value);

			if (dirty[0] & /*value*/ 2) {
				select_option(select, /*value*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(48:0) {#if type === 'select'}",
		ctx
	});

	return block;
}

function create_fragment$u(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block$8,
		create_if_block_1$3,
		create_if_block_2$3,
		create_if_block_3$1,
		create_else_block$7
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[4] === "select") return 0;
		if (/*type*/ ctx[4] === "file") return 1;
		if (/*type*/ ctx[4] === "switch" || /*type*/ ctx[4] === "checkbox") return 2;
		if (/*type*/ ctx[4] === "radio") return 3;
		return 4;
	}

	current_block_type_index = select_block_type(ctx, [-1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	let customClass;
	let validationClassNames;
	let combinedClasses;
	let fileClasses;
	let wrapperClasses;
	let customControlClasses;
	let labelHtmlFor;

	const omit_props_names = [
		"class","name","id","type","label","checked","disabled","inline","valid","value","invalid","bsSize","placeholder","for"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomInput", slots, ['default']);
	let { class: className = "" } = $$props;
	let { name = "" } = $$props;
	let { id = undefined } = $$props;
	let { type = null } = $$props;
	let { label = "" } = $$props;
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { inline = false } = $$props;
	let { valid = false } = $$props;
	let { value = "" } = $$props;
	let { invalid = false } = $$props;
	let { bsSize = "" } = $$props;
	let { placeholder = "" } = $$props;
	let { for: htmlFor = "" } = $$props;

	function blur_handler(event) {
		bubble($$self, event);
	}

	function focus_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function blur_handler_1(event) {
		bubble($$self, event);
	}

	function focus_handler_1(event) {
		bubble($$self, event);
	}

	function change_handler_1(event) {
		bubble($$self, event);
	}

	function input_handler_1(event) {
		bubble($$self, event);
	}

	function blur_handler_2(event) {
		bubble($$self, event);
	}

	function focus_handler_2(event) {
		bubble($$self, event);
	}

	function change_handler_2(event) {
		bubble($$self, event);
	}

	function input_handler_2(event) {
		bubble($$self, event);
	}

	function blur_handler_3(event) {
		bubble($$self, event);
	}

	function focus_handler_3(event) {
		bubble($$self, event);
	}

	function change_handler_3(event) {
		bubble($$self, event);
	}

	function input_handler_3(event) {
		bubble($$self, event);
	}

	function blur_handler_4(event) {
		bubble($$self, event);
	}

	function focus_handler_4(event) {
		bubble($$self, event);
	}

	function change_handler_4(event) {
		bubble($$self, event);
	}

	function input_handler_4(event) {
		bubble($$self, event);
	}

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(1, value);
	}

	function input_change_handler() {
		checked = this.checked;
		$$invalidate(0, checked);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(15, className = $$new_props.class);
		if ("name" in $$new_props) $$invalidate(2, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(3, id = $$new_props.id);
		if ("type" in $$new_props) $$invalidate(4, type = $$new_props.type);
		if ("label" in $$new_props) $$invalidate(5, label = $$new_props.label);
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
		if ("inline" in $$new_props) $$invalidate(16, inline = $$new_props.inline);
		if ("valid" in $$new_props) $$invalidate(17, valid = $$new_props.valid);
		if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ("invalid" in $$new_props) $$invalidate(18, invalid = $$new_props.invalid);
		if ("bsSize" in $$new_props) $$invalidate(19, bsSize = $$new_props.bsSize);
		if ("placeholder" in $$new_props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ("for" in $$new_props) $$invalidate(20, htmlFor = $$new_props.for);
		if ("$$scope" in $$new_props) $$invalidate(22, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		name,
		id,
		type,
		label,
		checked,
		disabled,
		inline,
		valid,
		value,
		invalid,
		bsSize,
		placeholder,
		htmlFor,
		customClass,
		validationClassNames,
		combinedClasses,
		fileClasses,
		wrapperClasses,
		customControlClasses,
		labelHtmlFor
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(15, className = $$new_props.className);
		if ("name" in $$props) $$invalidate(2, name = $$new_props.name);
		if ("id" in $$props) $$invalidate(3, id = $$new_props.id);
		if ("type" in $$props) $$invalidate(4, type = $$new_props.type);
		if ("label" in $$props) $$invalidate(5, label = $$new_props.label);
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
		if ("inline" in $$props) $$invalidate(16, inline = $$new_props.inline);
		if ("valid" in $$props) $$invalidate(17, valid = $$new_props.valid);
		if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
		if ("invalid" in $$props) $$invalidate(18, invalid = $$new_props.invalid);
		if ("bsSize" in $$props) $$invalidate(19, bsSize = $$new_props.bsSize);
		if ("placeholder" in $$props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ("htmlFor" in $$props) $$invalidate(20, htmlFor = $$new_props.htmlFor);
		if ("customClass" in $$props) $$invalidate(8, customClass = $$new_props.customClass);
		if ("validationClassNames" in $$props) $$invalidate(21, validationClassNames = $$new_props.validationClassNames);
		if ("combinedClasses" in $$props) $$invalidate(9, combinedClasses = $$new_props.combinedClasses);
		if ("fileClasses" in $$props) $$invalidate(10, fileClasses = $$new_props.fileClasses);
		if ("wrapperClasses" in $$props) $$invalidate(11, wrapperClasses = $$new_props.wrapperClasses);
		if ("customControlClasses" in $$props) $$invalidate(12, customControlClasses = $$new_props.customControlClasses);
		if ("labelHtmlFor" in $$props) $$invalidate(13, labelHtmlFor = $$new_props.labelHtmlFor);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*className, type, bsSize*/ 557072) {
			$: $$invalidate(8, customClass = classnames(className, `custom-${type}`, bsSize ? `custom-${type}-${bsSize}` : false));
		}

		if ($$self.$$.dirty[0] & /*invalid, valid*/ 393216) {
			$: $$invalidate(21, validationClassNames = classnames(invalid && "is-invalid", valid && "is-valid"));
		}

		if ($$self.$$.dirty[0] & /*customClass, validationClassNames*/ 2097408) {
			$: $$invalidate(9, combinedClasses = classnames(customClass, validationClassNames));
		}

		if ($$self.$$.dirty[0] & /*validationClassNames*/ 2097152) {
			$: $$invalidate(10, fileClasses = classnames(validationClassNames, "custom-file-input"));
		}

		if ($$self.$$.dirty[0] & /*customClass, inline*/ 65792) {
			$: $$invalidate(11, wrapperClasses = classnames(customClass, "custom-control", { "custom-control-inline": inline }));
		}

		if ($$self.$$.dirty[0] & /*validationClassNames*/ 2097152) {
			$: $$invalidate(12, customControlClasses = classnames(validationClassNames, "custom-control-input"));
		}

		if ($$self.$$.dirty[0] & /*htmlFor, id*/ 1048584) {
			$: $$invalidate(13, labelHtmlFor = htmlFor || id);
		}
	};

	return [
		checked,
		value,
		name,
		id,
		type,
		label,
		disabled,
		placeholder,
		customClass,
		combinedClasses,
		fileClasses,
		wrapperClasses,
		customControlClasses,
		labelHtmlFor,
		$$restProps,
		className,
		inline,
		valid,
		invalid,
		bsSize,
		htmlFor,
		validationClassNames,
		$$scope,
		slots,
		blur_handler,
		focus_handler,
		change_handler,
		input_handler,
		blur_handler_1,
		focus_handler_1,
		change_handler_1,
		input_handler_1,
		blur_handler_2,
		focus_handler_2,
		change_handler_2,
		input_handler_2,
		blur_handler_3,
		focus_handler_3,
		change_handler_3,
		input_handler_3,
		blur_handler_4,
		focus_handler_4,
		change_handler_4,
		input_handler_4,
		select_change_handler,
		input_change_handler
	];
}

class CustomInput extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$u,
			create_fragment$u,
			safe_not_equal,
			{
				class: 15,
				name: 2,
				id: 3,
				type: 4,
				label: 5,
				checked: 0,
				disabled: 6,
				inline: 16,
				valid: 17,
				value: 1,
				invalid: 18,
				bsSize: 19,
				placeholder: 7,
				for: 20
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomInput",
			options,
			id: create_fragment$u.name
		});
	}

	get class() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valid() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valid(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bsSize() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bsSize(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get for() {
		throw new Error("<CustomInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set for(value) {
		throw new Error("<CustomInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/DropdownItem.svelte generated by Svelte v3.37.0 */
const file$v = "node_modules/sveltestrap/src/DropdownItem.svelte";

// (49:0) {:else}
function create_else_block$8(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let button_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$v, 49, 2, 1086);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*click_handler_2*/ ctx[15], false, false, false),
					listen_dev(button, "click", /*handleItemClick*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(49:0) {:else}",
		ctx
	});

	return block;
}

// (45:15) 
function create_if_block_2$4(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let a_levels = [
		/*$$restProps*/ ctx[6],
		{ click: "" },
		{ href: /*href*/ ctx[2] },
		{ class: /*classes*/ ctx[3] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$v, 45, 2, 979);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*handleItemClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				{ click: "" },
				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(45:15) ",
		ctx
	});

	return block;
}

// (41:18) 
function create_if_block_1$4(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let div_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$v, 41, 2, 864);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "click", /*click_handler_1*/ ctx[14], false, false, false),
					listen_dev(div, "click", /*handleItemClick*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(41:18) ",
		ctx
	});

	return block;
}

// (37:0) {#if header}
function create_if_block$9(ctx) {
	let h6;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let h6_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let h6_data = {};

	for (let i = 0; i < h6_levels.length; i += 1) {
		h6_data = assign(h6_data, h6_levels[i]);
	}

	const block = {
		c: function create() {
			h6 = element("h6");
			if (default_slot) default_slot.c();
			set_attributes(h6, h6_data);
			add_location(h6, file$v, 37, 2, 748);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h6, anchor);

			if (default_slot) {
				default_slot.m(h6, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(h6, "click", /*click_handler*/ ctx[13], false, false, false),
					listen_dev(h6, "click", /*handleItemClick*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(h6, h6_data = get_spread_update(h6_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h6);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(37:0) {#if header}",
		ctx
	});

	return block;
}

function create_fragment$v(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$9, create_if_block_1$4, create_if_block_2$4, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*header*/ ctx[1]) return 0;
		if (/*divider*/ ctx[0]) return 1;
		if (/*href*/ ctx[2]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$v($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled","divider","header","toggle","href"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $context;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DropdownItem", slots, ['default']);
	const context = getContext("dropdownContext");
	validate_store(context, "context");
	component_subscribe($$self, context, value => $$invalidate(16, $context = value));
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { divider = false } = $$props;
	let { header = false } = $$props;
	let { toggle = true } = $$props;
	let { href = "" } = $$props;

	function handleItemClick(e) {
		if (disabled || header || divider) {
			e.preventDefault();
			return;
		}

		if (toggle) {
			$context.toggle(e);
		}
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	function click_handler_2(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(8, active = $$new_props.active);
		if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("divider" in $$new_props) $$invalidate(0, divider = $$new_props.divider);
		if ("header" in $$new_props) $$invalidate(1, header = $$new_props.header);
		if ("toggle" in $$new_props) $$invalidate(10, toggle = $$new_props.toggle);
		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		classnames,
		context,
		className,
		active,
		disabled,
		divider,
		header,
		toggle,
		href,
		handleItemClick,
		classes,
		$context
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(8, active = $$new_props.active);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("divider" in $$props) $$invalidate(0, divider = $$new_props.divider);
		if ("header" in $$props) $$invalidate(1, header = $$new_props.header);
		if ("toggle" in $$props) $$invalidate(10, toggle = $$new_props.toggle);
		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, disabled, divider, header, active*/ 899) {
			$: $$invalidate(3, classes = classnames(className, {
				disabled,
				"dropdown-item": !divider && !header,
				active,
				"dropdown-header": header,
				"dropdown-divider": divider
			}));
		}
	};

	return [
		divider,
		header,
		href,
		classes,
		context,
		handleItemClick,
		$$restProps,
		className,
		active,
		disabled,
		toggle,
		$$scope,
		slots,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class DropdownItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			class: 7,
			active: 8,
			disabled: 9,
			divider: 0,
			header: 1,
			toggle: 10,
			href: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DropdownItem",
			options,
			id: create_fragment$v.name
		});
	}

	get class() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get divider() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set divider(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get header() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/DropdownMenu.svelte generated by Svelte v3.37.0 */
const file$w = "node_modules/sveltestrap/src/DropdownMenu.svelte";

function create_fragment$w(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$w, 16, 0, 352);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$w($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","right"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $context;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DropdownMenu", slots, ['default']);
	const context = getContext("dropdownContext");
	validate_store(context, "context");
	component_subscribe($$self, context, value => $$invalidate(5, $context = value));
	let { class: className = "" } = $$props;
	let { right = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("right" in $$new_props) $$invalidate(4, right = $$new_props.right);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		classnames,
		context,
		className,
		right,
		classes,
		$context
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("right" in $$props) $$invalidate(4, right = $$new_props.right);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, right, $context*/ 56) {
			$: $$invalidate(0, classes = classnames(className, "dropdown-menu", {
				"dropdown-menu-right": right,
				show: $context.isOpen
			}));
		}
	};

	return [classes, context, $$restProps, className, right, $context, $$scope, slots];
}

class DropdownMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$w, create_fragment$w, safe_not_equal, { class: 3, right: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DropdownMenu",
			options,
			id: create_fragment$w.name
		});
	}

	get class() {
		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/DropdownToggle.svelte generated by Svelte v3.37.0 */
const file$x = "node_modules/sveltestrap/src/DropdownToggle.svelte";

// (67:0) {:else}
function create_else_block$9(ctx) {
	let button;
	let current;

	const button_spread_levels = [
		/*$$restProps*/ ctx[10],
		{ ariaHaspopup: /*ariaHaspopup*/ ctx[1] },
		{ class: /*classes*/ ctx[7] },
		{ color: /*color*/ ctx[0] },
		{ size: /*size*/ ctx[4] },
		{ outline: /*outline*/ ctx[6] }
	];

	let button_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < button_spread_levels.length; i += 1) {
		button_props = assign(button_props, button_spread_levels[i]);
	}

	button = new Button({ props: button_props, $$inline: true });
	button.$on("click", /*click_handler_2*/ ctx[18]);
	button.$on("click", /*toggleButton*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = (dirty & /*$$restProps, ariaHaspopup, classes, color, size, outline*/ 1235)
			? get_spread_update(button_spread_levels, [
					dirty & /*$$restProps*/ 1024 && get_spread_object(/*$$restProps*/ ctx[10]),
					dirty & /*ariaHaspopup*/ 2 && { ariaHaspopup: /*ariaHaspopup*/ ctx[1] },
					dirty & /*classes*/ 128 && { class: /*classes*/ ctx[7] },
					dirty & /*color*/ 1 && { color: /*color*/ ctx[0] },
					dirty & /*size*/ 16 && { size: /*size*/ ctx[4] },
					dirty & /*outline*/ 64 && { outline: /*outline*/ ctx[6] }
				])
			: {};

			if (dirty & /*$$scope, ariaLabel*/ 524292) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$9.name,
		type: "else",
		source: "(67:0) {:else}",
		ctx
	});

	return block;
}

// (54:25) 
function create_if_block_1$5(ctx) {
	let span;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

	let span_levels = [
		/*$$restProps*/ ctx[10],
		{ ariahaspopup: /*ariaHaspopup*/ ctx[1] },
		{ class: /*classes*/ ctx[7] },
		{ color: /*color*/ ctx[0] },
		{ size: /*size*/ ctx[4] }
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			set_attributes(span, span_data);
			add_location(span, file$x, 54, 2, 1098);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(span, "click", /*click_handler_1*/ ctx[17], false, false, false),
					listen_dev(span, "click", /*toggleButton*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*ariaLabel*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
				(!current || dirty & /*ariaHaspopup*/ 2) && { ariahaspopup: /*ariaHaspopup*/ ctx[1] },
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				(!current || dirty & /*color*/ 1) && { color: /*color*/ ctx[0] },
				(!current || dirty & /*size*/ 16) && { size: /*size*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(54:25) ",
		ctx
	});

	return block;
}

// (42:0) {#if nav}
function create_if_block$a(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	let a_levels = [
		/*$$restProps*/ ctx[10],
		{ href: "#nav" },
		{ ariahaspopup: /*ariaHaspopup*/ ctx[1] },
		{ class: /*classes*/ ctx[7] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			set_attributes(a, a_data);
			add_location(a, file$x, 42, 2, 872);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a, "click", /*click_handler*/ ctx[16], false, false, false),
					listen_dev(a, "click", /*toggleButton*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*ariaLabel*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
				{ href: "#nav" },
				(!current || dirty & /*ariaHaspopup*/ 2) && { ariahaspopup: /*ariaHaspopup*/ ctx[1] },
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(42:0) {#if nav}",
		ctx
	});

	return block;
}

// (77:10)        
function fallback_block_2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*ariaLabel*/ ctx[2]);
			attr_dev(span, "class", "sr-only");
			add_location(span, file$x, 77, 6, 1483);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block_2.name,
		type: "fallback",
		source: "(77:10)        ",
		ctx
	});

	return block;
}

// (68:2) <Button     {...$$restProps}     on:click     on:click={toggleButton}     {ariaHaspopup}     class={classes}     {color}     {size}     {outline}>
function create_default_slot$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block_2(ctx);

	const block = {
		c: function create() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m: function mount(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*ariaLabel*/ 4) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(68:2) <Button     {...$$restProps}     on:click     on:click={toggleButton}     {ariaHaspopup}     class={classes}     {color}     {size}     {outline}>",
		ctx
	});

	return block;
}

// (63:10)        
function fallback_block_1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*ariaLabel*/ ctx[2]);
			attr_dev(span, "class", "sr-only");
			add_location(span, file$x, 63, 6, 1246);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block_1.name,
		type: "fallback",
		source: "(63:10)        ",
		ctx
	});

	return block;
}

// (50:10)        
function fallback_block$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*ariaLabel*/ ctx[2]);
			attr_dev(span, "class", "sr-only");
			add_location(span, file$x, 50, 6, 1010);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(50:10)        ",
		ctx
	});

	return block;
}

function create_fragment$x(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$a, create_if_block_1$5, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nav*/ ctx[3]) return 0;
		if (/*tag*/ ctx[5] === "span") return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$x($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","caret","color","disabled","ariaHaspopup","ariaLabel","split","nav","size","tag","outline"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $context;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DropdownToggle", slots, ['default']);
	const context = getContext("dropdownContext");
	validate_store(context, "context");
	component_subscribe($$self, context, value => $$invalidate(20, $context = value));
	let { class: className = "" } = $$props;
	let { caret = false } = $$props;
	let { color = "secondary" } = $$props;
	let { disabled = false } = $$props;
	let { ariaHaspopup = true } = $$props;
	let { ariaLabel = "Toggle Dropdown" } = $$props;
	let { split = false } = $$props;
	let { nav = false } = $$props;
	let { size = "" } = $$props;
	let { tag = null } = $$props;
	let { outline = false } = $$props;

	function toggleButton(e) {
		if (disabled) {
			e.preventDefault();
			return;
		}

		if (nav) {
			e.preventDefault();
		}

		$context.toggle(e);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	function click_handler_2(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(11, className = $$new_props.class);
		if ("caret" in $$new_props) $$invalidate(12, caret = $$new_props.caret);
		if ("color" in $$new_props) $$invalidate(0, color = $$new_props.color);
		if ("disabled" in $$new_props) $$invalidate(13, disabled = $$new_props.disabled);
		if ("ariaHaspopup" in $$new_props) $$invalidate(1, ariaHaspopup = $$new_props.ariaHaspopup);
		if ("ariaLabel" in $$new_props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
		if ("split" in $$new_props) $$invalidate(14, split = $$new_props.split);
		if ("nav" in $$new_props) $$invalidate(3, nav = $$new_props.nav);
		if ("size" in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ("tag" in $$new_props) $$invalidate(5, tag = $$new_props.tag);
		if ("outline" in $$new_props) $$invalidate(6, outline = $$new_props.outline);
		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		classnames,
		Button,
		context,
		className,
		caret,
		color,
		disabled,
		ariaHaspopup,
		ariaLabel,
		split,
		nav,
		size,
		tag,
		outline,
		toggleButton,
		classes,
		$context
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(11, className = $$new_props.className);
		if ("caret" in $$props) $$invalidate(12, caret = $$new_props.caret);
		if ("color" in $$props) $$invalidate(0, color = $$new_props.color);
		if ("disabled" in $$props) $$invalidate(13, disabled = $$new_props.disabled);
		if ("ariaHaspopup" in $$props) $$invalidate(1, ariaHaspopup = $$new_props.ariaHaspopup);
		if ("ariaLabel" in $$props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
		if ("split" in $$props) $$invalidate(14, split = $$new_props.split);
		if ("nav" in $$props) $$invalidate(3, nav = $$new_props.nav);
		if ("size" in $$props) $$invalidate(4, size = $$new_props.size);
		if ("tag" in $$props) $$invalidate(5, tag = $$new_props.tag);
		if ("outline" in $$props) $$invalidate(6, outline = $$new_props.outline);
		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, caret, split, nav*/ 22536) {
			$: $$invalidate(7, classes = classnames(className, {
				"dropdown-toggle": caret || split,
				"dropdown-toggle-split": split,
				"nav-link": nav
			}));
		}
	};

	return [
		color,
		ariaHaspopup,
		ariaLabel,
		nav,
		size,
		tag,
		outline,
		classes,
		context,
		toggleButton,
		$$restProps,
		className,
		caret,
		disabled,
		split,
		slots,
		click_handler,
		click_handler_1,
		click_handler_2,
		$$scope
	];
}

class DropdownToggle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			class: 11,
			caret: 12,
			color: 0,
			disabled: 13,
			ariaHaspopup: 1,
			ariaLabel: 2,
			split: 14,
			nav: 3,
			size: 4,
			tag: 5,
			outline: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DropdownToggle",
			options,
			id: create_fragment$x.name
		});
	}

	get class() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get caret() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set caret(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaHaspopup() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaHaspopup(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get split() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set split(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nav() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nav(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Fade.svelte generated by Svelte v3.37.0 */
const file$y = "node_modules/sveltestrap/src/Fade.svelte";

// (14:0) {#if isOpen}
function create_if_block$b(ctx) {
	let div;
	let div_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [/*$$restProps*/ ctx[6], { class: /*className*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$y, 14, 2, 320);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "introstart", /*introstart_handler*/ ctx[9], false, false, false),
					listen_dev(div, "introend", /*introend_handler*/ ctx[10], false, false, false),
					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[11], false, false, false),
					listen_dev(div, "outroend", /*outroend_handler*/ ctx[12], false, false, false),
					listen_dev(
						div,
						"introstart",
						function () {
							if (is_function(/*onEntering*/ ctx[2])) /*onEntering*/ ctx[2].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div,
						"introend",
						function () {
							if (is_function(/*onEntered*/ ctx[3])) /*onEntered*/ ctx[3].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div,
						"outrostart",
						function () {
							if (is_function(/*onExiting*/ ctx[4])) /*onExiting*/ ctx[4].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div,
						"outroend",
						function () {
							if (is_function(/*onExited*/ ctx[5])) /*onExited*/ ctx[5].apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*className*/ 2) && { class: /*className*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (local) {
				add_render_callback(() => {
					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(14:0) {#if isOpen}",
		ctx
	});

	return block;
}

function create_fragment$y(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$b(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$y($$self, $$props, $$invalidate) {
	const omit_props_names = ["isOpen","class","onEntering","onEntered","onExiting","onExited"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fade", slots, ['default']);
	const noop = () => undefined;
	let { isOpen = false } = $$props;
	let { class: className = "" } = $$props;
	let { onEntering = noop } = $$props;
	let { onEntered = noop } = $$props;
	let { onExiting = noop } = $$props;
	let { onExited = noop } = $$props;

	function introstart_handler(event) {
		bubble($$self, event);
	}

	function introend_handler(event) {
		bubble($$self, event);
	}

	function outrostart_handler(event) {
		bubble($$self, event);
	}

	function outroend_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("onEntering" in $$new_props) $$invalidate(2, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$new_props) $$invalidate(3, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$new_props) $$invalidate(4, onExiting = $$new_props.onExiting);
		if ("onExited" in $$new_props) $$invalidate(5, onExited = $$new_props.onExited);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		fade,
		noop,
		isOpen,
		className,
		onEntering,
		onEntered,
		onExiting,
		onExited
	});

	$$self.$inject_state = $$new_props => {
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("onEntering" in $$props) $$invalidate(2, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$props) $$invalidate(3, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$props) $$invalidate(4, onExiting = $$new_props.onExiting);
		if ("onExited" in $$props) $$invalidate(5, onExited = $$new_props.onExited);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		isOpen,
		className,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		$$restProps,
		$$scope,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler
	];
}

class Fade extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
			isOpen: 0,
			class: 1,
			onEntering: 2,
			onEntered: 3,
			onExiting: 4,
			onExited: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fade",
			options,
			id: create_fragment$y.name
		});
	}

	get isOpen() {
		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntering() {
		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntering(value) {
		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntered() {
		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntered(value) {
		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExiting() {
		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExiting(value) {
		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExited() {
		throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExited(value) {
		throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Form.svelte generated by Svelte v3.37.0 */
const file$z = "node_modules/sveltestrap/src/Form.svelte";

function create_fragment$z(ctx) {
	let form;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let form_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let form_data = {};

	for (let i = 0; i < form_levels.length; i += 1) {
		form_data = assign(form_data, form_levels[i]);
	}

	const block = {
		c: function create() {
			form = element("form");
			if (default_slot) default_slot.c();
			set_attributes(form, form_data);
			add_location(form, file$z, 10, 0, 212);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "submit", /*submit_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(form, form_data = get_spread_update(form_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$z($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","inline"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Form", slots, ['default']);
	let { class: className = "" } = $$props;
	let { inline = false } = $$props;

	function submit_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("inline" in $$new_props) $$invalidate(3, inline = $$new_props.inline);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, inline, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("inline" in $$props) $$invalidate(3, inline = $$new_props.inline);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, inline*/ 12) {
			$: $$invalidate(0, classes = classnames(className, inline ? "form-inline" : false));
		}
	};

	return [classes, $$restProps, className, inline, $$scope, slots, submit_handler];
}

class Form extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$z, create_fragment$z, safe_not_equal, { class: 2, inline: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Form",
			options,
			id: create_fragment$z.name
		});
	}

	get class() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/FormFeedback.svelte generated by Svelte v3.37.0 */
const file$A = "node_modules/sveltestrap/src/FormFeedback.svelte";

function create_fragment$A(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$A, 19, 0, 368);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$A($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","valid","tooltip"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FormFeedback", slots, ['default']);
	let { class: className = "" } = $$props;
	let { valid = undefined } = $$props;
	let { tooltip = false } = $$props;
	let classes;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("valid" in $$new_props) $$invalidate(3, valid = $$new_props.valid);
		if ("tooltip" in $$new_props) $$invalidate(4, tooltip = $$new_props.tooltip);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		valid,
		tooltip,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("valid" in $$props) $$invalidate(3, valid = $$new_props.valid);
		if ("tooltip" in $$props) $$invalidate(4, tooltip = $$new_props.tooltip);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*tooltip, className, valid*/ 28) {
			$: {
				const validMode = tooltip ? "tooltip" : "feedback";
				$$invalidate(0, classes = classnames(className, valid ? `valid-${validMode}` : `invalid-${validMode}`));
			}
		}
	};

	return [classes, $$restProps, className, valid, tooltip, $$scope, slots];
}

class FormFeedback extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$A, create_fragment$A, safe_not_equal, { class: 2, valid: 3, tooltip: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FormFeedback",
			options,
			id: create_fragment$A.name
		});
	}

	get class() {
		throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valid() {
		throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valid(value) {
		throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/FormGroup.svelte generated by Svelte v3.37.0 */
const file$B = "node_modules/sveltestrap/src/FormGroup.svelte";

// (25:0) {:else}
function create_else_block$a(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$B, 25, 2, 574);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$a.name,
		type: "else",
		source: "(25:0) {:else}",
		ctx
	});

	return block;
}

// (21:0) {#if tag === 'fieldset'}
function create_if_block$c(ctx) {
	let fieldset;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let fieldset_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let fieldset_data = {};

	for (let i = 0; i < fieldset_levels.length; i += 1) {
		fieldset_data = assign(fieldset_data, fieldset_levels[i]);
	}

	const block = {
		c: function create() {
			fieldset = element("fieldset");
			if (default_slot) default_slot.c();
			set_attributes(fieldset, fieldset_data);
			add_location(fieldset, file$B, 21, 2, 493);
		},
		m: function mount(target, anchor) {
			insert_dev(target, fieldset, anchor);

			if (default_slot) {
				default_slot.m(fieldset, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(fieldset);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(21:0) {#if tag === 'fieldset'}",
		ctx
	});

	return block;
}

function create_fragment$B(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$c, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "fieldset") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$B($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","row","check","inline","disabled","tag"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FormGroup", slots, ['default']);
	let { class: className = "" } = $$props;
	let { row = false } = $$props;
	let { check = false } = $$props;
	let { inline = false } = $$props;
	let { disabled = false } = $$props;
	let { tag = null } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("row" in $$new_props) $$invalidate(4, row = $$new_props.row);
		if ("check" in $$new_props) $$invalidate(5, check = $$new_props.check);
		if ("inline" in $$new_props) $$invalidate(6, inline = $$new_props.inline);
		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		row,
		check,
		inline,
		disabled,
		tag,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("row" in $$props) $$invalidate(4, row = $$new_props.row);
		if ("check" in $$props) $$invalidate(5, check = $$new_props.check);
		if ("inline" in $$props) $$invalidate(6, inline = $$new_props.inline);
		if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, row, check, inline, disabled*/ 248) {
			$: $$invalidate(1, classes = classnames(className, row ? "row" : false, check ? "form-check" : "form-group", check && inline ? "form-check-inline" : false, check && disabled ? "disabled" : false));
		}
	};

	return [
		tag,
		classes,
		$$restProps,
		className,
		row,
		check,
		inline,
		disabled,
		$$scope,
		slots
	];
}

class FormGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			class: 3,
			row: 4,
			check: 5,
			inline: 6,
			disabled: 7,
			tag: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FormGroup",
			options,
			id: create_fragment$B.name
		});
	}

	get class() {
		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get row() {
		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set row(value) {
		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get check() {
		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set check(value) {
		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline() {
		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline(value) {
		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/FormText.svelte generated by Svelte v3.37.0 */
const file$C = "node_modules/sveltestrap/src/FormText.svelte";

function create_fragment$C(ctx) {
	let small;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let small_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let small_data = {};

	for (let i = 0; i < small_levels.length; i += 1) {
		small_data = assign(small_data, small_levels[i]);
	}

	const block = {
		c: function create() {
			small = element("small");
			if (default_slot) default_slot.c();
			set_attributes(small, small_data);
			add_location(small, file$C, 15, 0, 290);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, small, anchor);

			if (default_slot) {
				default_slot.m(small, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(small, small_data = get_spread_update(small_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(small);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$C($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","inline","color"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FormText", slots, ['default']);
	let { class: className = "" } = $$props;
	let { inline = false } = $$props;
	let { color = "muted" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("inline" in $$new_props) $$invalidate(3, inline = $$new_props.inline);
		if ("color" in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		inline,
		color,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("inline" in $$props) $$invalidate(3, inline = $$new_props.inline);
		if ("color" in $$props) $$invalidate(4, color = $$new_props.color);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, inline, color*/ 28) {
			$: $$invalidate(0, classes = classnames(className, !inline ? "form-text" : false, color ? `text-${color}` : false));
		}
	};

	return [classes, $$restProps, className, inline, color, $$scope, slots];
}

class FormText extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$C, create_fragment$C, safe_not_equal, { class: 2, inline: 3, color: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FormText",
			options,
			id: create_fragment$C.name
		});
	}

	get class() {
		throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline() {
		throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline(value) {
		throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Icon.svelte generated by Svelte v3.37.0 */
const file$D = "node_modules/sveltestrap/src/Icon.svelte";

function create_fragment$D(ctx) {
	let i;
	let i_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			set_attributes(i, i_data);
			add_location(i, file$D, 14, 0, 301);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
		},
		p: function update(ctx, [dirty]) {
			set_attributes(i, i_data = get_spread_update(i_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] }
			]));
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$D($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","name"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Icon", slots, []);
	let { class: className = "" } = $$props;
	let { name = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("name" in $$new_props) $$invalidate(3, name = $$new_props.name);
	};

	$$self.$capture_state = () => ({ classnames, className, name, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("name" in $$props) $$invalidate(3, name = $$new_props.name);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, name*/ 12) {
			$: $$invalidate(0, classes = classnames(className, `bi-${name}`));
		}
	};

	return [classes, $$restProps, className, name];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$D, create_fragment$D, safe_not_equal, { class: 2, name: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$D.name
		});
	}

	get class() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Input.svelte generated by Svelte v3.37.0 */
const file$E = "node_modules/sveltestrap/src/Input.svelte";

// (356:40) 
function create_if_block_16(ctx) {
	let select;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

	let select_levels = [
		/*$$restProps*/ ctx[12],
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ readonly: /*readonly*/ ctx[4] }
	];

	let select_data = {};

	for (let i = 0; i < select_levels.length; i += 1) {
		select_data = assign(select_data, select_levels[i]);
	}

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			set_attributes(select, select_data);
			if (/*value*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[152].call(select));
			add_location(select, file$E, 356, 2, 7097);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			if (select_data.multiple) select_options(select, select_data.value);
			select_option(select, /*value*/ ctx[1]);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "blur", /*blur_handler_16*/ ctx[133], false, false, false),
					listen_dev(select, "focus", /*focus_handler_16*/ ctx[134], false, false, false),
					listen_dev(select, "change", /*change_handler_15*/ ctx[135], false, false, false),
					listen_dev(select, "input", /*input_handler_15*/ ctx[136], false, false, false),
					listen_dev(select, "change", /*select_change_handler*/ ctx[152])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 2097152) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
				}
			}

			set_attributes(select, select_data = get_spread_update(select_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
				(!current || dirty[0] & /*name*/ 64) && { name: /*name*/ ctx[6] },
				(!current || dirty[0] & /*disabled*/ 256) && { disabled: /*disabled*/ ctx[8] },
				(!current || dirty[0] & /*readonly*/ 16) && { readonly: /*readonly*/ ctx[4] }
			]));

			if (dirty[0] & /*$$restProps, classes, name, disabled, readonly*/ 4944 && select_data.multiple) select_options(select, select_data.value);

			if (dirty[0] & /*value*/ 2) {
				select_option(select, /*value*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16.name,
		type: "if",
		source: "(356:40) ",
		ctx
	});

	return block;
}

// (340:29) 
function create_if_block_15(ctx) {
	let textarea;
	let mounted;
	let dispose;

	let textarea_levels = [
		/*$$restProps*/ ctx[12],
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] },
		{ readOnly: /*readonly*/ ctx[4] }
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			set_attributes(textarea, textarea_data);
			add_location(textarea, file$E, 340, 2, 6830);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "blur", /*blur_handler_15*/ ctx[126], false, false, false),
					listen_dev(textarea, "focus", /*focus_handler_15*/ ctx[127], false, false, false),
					listen_dev(textarea, "keydown", /*keydown_handler_15*/ ctx[128], false, false, false),
					listen_dev(textarea, "keypress", /*keypress_handler_15*/ ctx[129], false, false, false),
					listen_dev(textarea, "keyup", /*keyup_handler_15*/ ctx[130], false, false, false),
					listen_dev(textarea, "change", /*change_handler_14*/ ctx[131], false, false, false),
					listen_dev(textarea, "input", /*input_handler_14*/ ctx[132], false, false, false),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[151])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(textarea, /*value*/ ctx[1]);
			}
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15.name,
		type: "if",
		source: "(340:29) ",
		ctx
	});

	return block;
}

// (82:0) {#if tag === 'input'}
function create_if_block$d(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[3] === "text") return create_if_block_1$6;
		if (/*type*/ ctx[3] === "password") return create_if_block_2$5;
		if (/*type*/ ctx[3] === "email") return create_if_block_3$2;
		if (/*type*/ ctx[3] === "file") return create_if_block_4;
		if (/*type*/ ctx[3] === "checkbox") return create_if_block_5;
		if (/*type*/ ctx[3] === "radio") return create_if_block_6;
		if (/*type*/ ctx[3] === "url") return create_if_block_7;
		if (/*type*/ ctx[3] === "number") return create_if_block_8;
		if (/*type*/ ctx[3] === "date") return create_if_block_9;
		if (/*type*/ ctx[3] === "time") return create_if_block_10;
		if (/*type*/ ctx[3] === "datetime") return create_if_block_11;
		if (/*type*/ ctx[3] === "color") return create_if_block_12;
		if (/*type*/ ctx[3] === "range") return create_if_block_13;
		if (/*type*/ ctx[3] === "search") return create_if_block_14;
		return create_else_block$b;
	}

	let current_block_type = select_block_type_1(ctx, [-1]);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(82:0) {#if tag === 'input'}",
		ctx
	});

	return block;
}

// (322:2) {:else}
function create_else_block$b(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: /*type*/ ctx[3] },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] },
		{ value: /*value*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 322, 4, 6503);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			input.value = input_data.value;

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_14*/ ctx[121], false, false, false),
					listen_dev(input, "focus", /*focus_handler_14*/ ctx[122], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_14*/ ctx[123], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_14*/ ctx[124], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_14*/ ctx[125], false, false, false),
					listen_dev(input, "input", /*handleInput*/ ctx[11], false, false, false),
					listen_dev(input, "change", /*handleInput*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				dirty[0] & /*type*/ 8 && { type: /*type*/ ctx[3] },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] },
				dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1] && { value: /*value*/ ctx[1] }
			]));

			if ("value" in input_data) {
				input.value = input_data.value;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$b.name,
		type: "else",
		source: "(322:2) {:else}",
		ctx
	});

	return block;
}

// (305:30) 
function create_if_block_14(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "search" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 305, 4, 6220);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_13*/ ctx[114], false, false, false),
					listen_dev(input, "focus", /*focus_handler_13*/ ctx[115], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_13*/ ctx[116], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_13*/ ctx[117], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_13*/ ctx[118], false, false, false),
					listen_dev(input, "change", /*change_handler_13*/ ctx[119], false, false, false),
					listen_dev(input, "input", /*input_handler_13*/ ctx[120], false, false, false),
					listen_dev(input, "input", /*input_input_handler_9*/ ctx[150])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "search" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14.name,
		type: "if",
		source: "(305:30) ",
		ctx
	});

	return block;
}

// (288:29) 
function create_if_block_13(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "range" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 288, 4, 5917);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_12*/ ctx[107], false, false, false),
					listen_dev(input, "focus", /*focus_handler_12*/ ctx[108], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_12*/ ctx[109], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_12*/ ctx[110], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_12*/ ctx[111], false, false, false),
					listen_dev(input, "change", /*change_handler_12*/ ctx[112], false, false, false),
					listen_dev(input, "input", /*input_handler_12*/ ctx[113], false, false, false),
					listen_dev(input, "change", /*input_change_input_handler*/ ctx[149]),
					listen_dev(input, "input", /*input_change_input_handler*/ ctx[149])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "range" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(288:29) ",
		ctx
	});

	return block;
}

// (271:29) 
function create_if_block_12(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "color" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 271, 4, 5615);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_11*/ ctx[100], false, false, false),
					listen_dev(input, "focus", /*focus_handler_11*/ ctx[101], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_11*/ ctx[102], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_11*/ ctx[103], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_11*/ ctx[104], false, false, false),
					listen_dev(input, "change", /*change_handler_11*/ ctx[105], false, false, false),
					listen_dev(input, "input", /*input_handler_11*/ ctx[106], false, false, false),
					listen_dev(input, "input", /*input_input_handler_8*/ ctx[148])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "color" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(271:29) ",
		ctx
	});

	return block;
}

// (254:32) 
function create_if_block_11(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "datetime" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 254, 4, 5310);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_10*/ ctx[93], false, false, false),
					listen_dev(input, "focus", /*focus_handler_10*/ ctx[94], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_10*/ ctx[95], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_10*/ ctx[96], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_10*/ ctx[97], false, false, false),
					listen_dev(input, "change", /*change_handler_10*/ ctx[98], false, false, false),
					listen_dev(input, "input", /*input_handler_10*/ ctx[99], false, false, false),
					listen_dev(input, "input", /*input_input_handler_7*/ ctx[147])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "datetime" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(254:32) ",
		ctx
	});

	return block;
}

// (237:28) 
function create_if_block_10(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "time" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 237, 4, 5006);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_9*/ ctx[86], false, false, false),
					listen_dev(input, "focus", /*focus_handler_9*/ ctx[87], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_9*/ ctx[88], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_9*/ ctx[89], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_9*/ ctx[90], false, false, false),
					listen_dev(input, "change", /*change_handler_9*/ ctx[91], false, false, false),
					listen_dev(input, "input", /*input_handler_9*/ ctx[92], false, false, false),
					listen_dev(input, "input", /*input_input_handler_6*/ ctx[146])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "time" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(237:28) ",
		ctx
	});

	return block;
}

// (220:28) 
function create_if_block_9(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "date" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 220, 4, 4706);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_8*/ ctx[79], false, false, false),
					listen_dev(input, "focus", /*focus_handler_8*/ ctx[80], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_8*/ ctx[81], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_8*/ ctx[82], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_8*/ ctx[83], false, false, false),
					listen_dev(input, "change", /*change_handler_8*/ ctx[84], false, false, false),
					listen_dev(input, "input", /*input_handler_8*/ ctx[85], false, false, false),
					listen_dev(input, "input", /*input_input_handler_5*/ ctx[145])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "date" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(220:28) ",
		ctx
	});

	return block;
}

// (203:30) 
function create_if_block_8(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "number" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 203, 4, 4404);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_7*/ ctx[72], false, false, false),
					listen_dev(input, "focus", /*focus_handler_7*/ ctx[73], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_7*/ ctx[74], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_7*/ ctx[75], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_7*/ ctx[76], false, false, false),
					listen_dev(input, "change", /*change_handler_7*/ ctx[77], false, false, false),
					listen_dev(input, "input", /*input_handler_7*/ ctx[78], false, false, false),
					listen_dev(input, "input", /*input_input_handler_4*/ ctx[144])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "number" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2 && to_number(input.value) !== /*value*/ ctx[1]) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(203:30) ",
		ctx
	});

	return block;
}

// (186:27) 
function create_if_block_7(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "url" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 186, 4, 4103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_6*/ ctx[65], false, false, false),
					listen_dev(input, "focus", /*focus_handler_6*/ ctx[66], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_6*/ ctx[67], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_6*/ ctx[68], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_6*/ ctx[69], false, false, false),
					listen_dev(input, "change", /*change_handler_6*/ ctx[70], false, false, false),
					listen_dev(input, "input", /*input_handler_6*/ ctx[71], false, false, false),
					listen_dev(input, "input", /*input_input_handler_3*/ ctx[143])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "url" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(186:27) ",
		ctx
	});

	return block;
}

// (169:29) 
function create_if_block_6(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "radio" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 169, 4, 3803);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_5*/ ctx[58], false, false, false),
					listen_dev(input, "focus", /*focus_handler_5*/ ctx[59], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_5*/ ctx[60], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_5*/ ctx[61], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_5*/ ctx[62], false, false, false),
					listen_dev(input, "change", /*change_handler_5*/ ctx[63], false, false, false),
					listen_dev(input, "input", /*input_handler_5*/ ctx[64], false, false, false),
					listen_dev(input, "change", /*input_change_handler_2*/ ctx[142])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "radio" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(169:29) ",
		ctx
	});

	return block;
}

// (151:32) 
function create_if_block_5(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "checkbox" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 151, 4, 3479);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			input.checked = /*checked*/ ctx[0];
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_4*/ ctx[51], false, false, false),
					listen_dev(input, "focus", /*focus_handler_4*/ ctx[52], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_4*/ ctx[53], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_4*/ ctx[54], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_4*/ ctx[55], false, false, false),
					listen_dev(input, "change", /*change_handler_4*/ ctx[56], false, false, false),
					listen_dev(input, "input", /*input_handler_4*/ ctx[57], false, false, false),
					listen_dev(input, "change", /*input_change_handler_1*/ ctx[141])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "checkbox" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty[0] & /*value*/ 2) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(151:32) ",
		ctx
	});

	return block;
}

// (134:28) 
function create_if_block_4(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "file" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 134, 4, 3175);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_3*/ ctx[44], false, false, false),
					listen_dev(input, "focus", /*focus_handler_3*/ ctx[45], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_3*/ ctx[46], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_3*/ ctx[47], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_3*/ ctx[48], false, false, false),
					listen_dev(input, "change", /*change_handler_3*/ ctx[49], false, false, false),
					listen_dev(input, "input", /*input_handler_3*/ ctx[50], false, false, false),
					listen_dev(input, "change", /*input_change_handler*/ ctx[140])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "file" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(134:28) ",
		ctx
	});

	return block;
}

// (117:29) 
function create_if_block_3$2(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "email" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 117, 4, 2874);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_2*/ ctx[37], false, false, false),
					listen_dev(input, "focus", /*focus_handler_2*/ ctx[38], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_2*/ ctx[39], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_2*/ ctx[40], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_2*/ ctx[41], false, false, false),
					listen_dev(input, "change", /*change_handler_2*/ ctx[42], false, false, false),
					listen_dev(input, "input", /*input_handler_2*/ ctx[43], false, false, false),
					listen_dev(input, "input", /*input_input_handler_2*/ ctx[139])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "email" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(117:29) ",
		ctx
	});

	return block;
}

// (100:32) 
function create_if_block_2$5(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "password" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 100, 4, 2569);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[30], false, false, false),
					listen_dev(input, "focus", /*focus_handler_1*/ ctx[31], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler_1*/ ctx[32], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler_1*/ ctx[33], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler_1*/ ctx[34], false, false, false),
					listen_dev(input, "change", /*change_handler_1*/ ctx[35], false, false, false),
					listen_dev(input, "input", /*input_handler_1*/ ctx[36], false, false, false),
					listen_dev(input, "input", /*input_input_handler_1*/ ctx[138])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "password" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(100:32) ",
		ctx
	});

	return block;
}

// (83:2) {#if type === 'text'}
function create_if_block_1$6(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[12],
		{ type: "text" },
		{ readOnly: /*readonly*/ ctx[4] },
		{ class: /*classes*/ ctx[9] },
		{ name: /*name*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$E, 83, 4, 2265);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "blur", /*blur_handler*/ ctx[23], false, false, false),
					listen_dev(input, "focus", /*focus_handler*/ ctx[24], false, false, false),
					listen_dev(input, "keydown", /*keydown_handler*/ ctx[25], false, false, false),
					listen_dev(input, "keypress", /*keypress_handler*/ ctx[26], false, false, false),
					listen_dev(input, "keyup", /*keyup_handler*/ ctx[27], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[28], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[29], false, false, false),
					listen_dev(input, "input", /*input_input_handler*/ ctx[137])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
				{ type: "text" },
				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
			]));

			if (dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
				set_input_value(input, /*value*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(83:2) {#if type === 'text'}",
		ctx
	});

	return block;
}

function create_fragment$E(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$d, create_if_block_15, create_if_block_16];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[10] === "input") return 0;
		if (/*tag*/ ctx[10] === "textarea") return 1;
		if (/*tag*/ ctx[10] === "select" && !/*multiple*/ ctx[5]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$E($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","type","size","bsSize","color","checked","valid","invalid","plaintext","addon","value","files","readonly","multiple","name","placeholder","disabled"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Input", slots, ['default']);
	let { class: className = "" } = $$props;
	let { type = "text" } = $$props;
	let { size = undefined } = $$props;
	let { bsSize = undefined } = $$props;
	let { color = undefined } = $$props;
	let { checked = false } = $$props;
	let { valid = false } = $$props;
	let { invalid = false } = $$props;
	let { plaintext = false } = $$props;
	let { addon = false } = $$props;
	let { value = "" } = $$props;
	let { files = "" } = $$props;
	let { readonly = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { name = "" } = $$props;
	let { placeholder = "" } = $$props;
	let { disabled = undefined } = $$props;
	let classes;
	let tag;

	const handleInput = event => {
		$$invalidate(1, value = event.target.value);
	};

	function blur_handler(event) {
		bubble($$self, event);
	}

	function focus_handler(event) {
		bubble($$self, event);
	}

	function keydown_handler(event) {
		bubble($$self, event);
	}

	function keypress_handler(event) {
		bubble($$self, event);
	}

	function keyup_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function blur_handler_1(event) {
		bubble($$self, event);
	}

	function focus_handler_1(event) {
		bubble($$self, event);
	}

	function keydown_handler_1(event) {
		bubble($$self, event);
	}

	function keypress_handler_1(event) {
		bubble($$self, event);
	}

	function keyup_handler_1(event) {
		bubble($$self, event);
	}

	function change_handler_1(event) {
		bubble($$self, event);
	}

	function input_handler_1(event) {
		bubble($$self, event);
	}

	function blur_handler_2(event) {
		bubble($$self, event);
	}

	function focus_handler_2(event) {
		bubble($$self, event);
	}

	function keydown_handler_2(event) {
		bubble($$self, event);
	}

	function keypress_handler_2(event) {
		bubble($$self, event);
	}

	function keyup_handler_2(event) {
		bubble($$self, event);
	}

	function change_handler_2(event) {
		bubble($$self, event);
	}

	function input_handler_2(event) {
		bubble($$self, event);
	}

	function blur_handler_3(event) {
		bubble($$self, event);
	}

	function focus_handler_3(event) {
		bubble($$self, event);
	}

	function keydown_handler_3(event) {
		bubble($$self, event);
	}

	function keypress_handler_3(event) {
		bubble($$self, event);
	}

	function keyup_handler_3(event) {
		bubble($$self, event);
	}

	function change_handler_3(event) {
		bubble($$self, event);
	}

	function input_handler_3(event) {
		bubble($$self, event);
	}

	function blur_handler_4(event) {
		bubble($$self, event);
	}

	function focus_handler_4(event) {
		bubble($$self, event);
	}

	function keydown_handler_4(event) {
		bubble($$self, event);
	}

	function keypress_handler_4(event) {
		bubble($$self, event);
	}

	function keyup_handler_4(event) {
		bubble($$self, event);
	}

	function change_handler_4(event) {
		bubble($$self, event);
	}

	function input_handler_4(event) {
		bubble($$self, event);
	}

	function blur_handler_5(event) {
		bubble($$self, event);
	}

	function focus_handler_5(event) {
		bubble($$self, event);
	}

	function keydown_handler_5(event) {
		bubble($$self, event);
	}

	function keypress_handler_5(event) {
		bubble($$self, event);
	}

	function keyup_handler_5(event) {
		bubble($$self, event);
	}

	function change_handler_5(event) {
		bubble($$self, event);
	}

	function input_handler_5(event) {
		bubble($$self, event);
	}

	function blur_handler_6(event) {
		bubble($$self, event);
	}

	function focus_handler_6(event) {
		bubble($$self, event);
	}

	function keydown_handler_6(event) {
		bubble($$self, event);
	}

	function keypress_handler_6(event) {
		bubble($$self, event);
	}

	function keyup_handler_6(event) {
		bubble($$self, event);
	}

	function change_handler_6(event) {
		bubble($$self, event);
	}

	function input_handler_6(event) {
		bubble($$self, event);
	}

	function blur_handler_7(event) {
		bubble($$self, event);
	}

	function focus_handler_7(event) {
		bubble($$self, event);
	}

	function keydown_handler_7(event) {
		bubble($$self, event);
	}

	function keypress_handler_7(event) {
		bubble($$self, event);
	}

	function keyup_handler_7(event) {
		bubble($$self, event);
	}

	function change_handler_7(event) {
		bubble($$self, event);
	}

	function input_handler_7(event) {
		bubble($$self, event);
	}

	function blur_handler_8(event) {
		bubble($$self, event);
	}

	function focus_handler_8(event) {
		bubble($$self, event);
	}

	function keydown_handler_8(event) {
		bubble($$self, event);
	}

	function keypress_handler_8(event) {
		bubble($$self, event);
	}

	function keyup_handler_8(event) {
		bubble($$self, event);
	}

	function change_handler_8(event) {
		bubble($$self, event);
	}

	function input_handler_8(event) {
		bubble($$self, event);
	}

	function blur_handler_9(event) {
		bubble($$self, event);
	}

	function focus_handler_9(event) {
		bubble($$self, event);
	}

	function keydown_handler_9(event) {
		bubble($$self, event);
	}

	function keypress_handler_9(event) {
		bubble($$self, event);
	}

	function keyup_handler_9(event) {
		bubble($$self, event);
	}

	function change_handler_9(event) {
		bubble($$self, event);
	}

	function input_handler_9(event) {
		bubble($$self, event);
	}

	function blur_handler_10(event) {
		bubble($$self, event);
	}

	function focus_handler_10(event) {
		bubble($$self, event);
	}

	function keydown_handler_10(event) {
		bubble($$self, event);
	}

	function keypress_handler_10(event) {
		bubble($$self, event);
	}

	function keyup_handler_10(event) {
		bubble($$self, event);
	}

	function change_handler_10(event) {
		bubble($$self, event);
	}

	function input_handler_10(event) {
		bubble($$self, event);
	}

	function blur_handler_11(event) {
		bubble($$self, event);
	}

	function focus_handler_11(event) {
		bubble($$self, event);
	}

	function keydown_handler_11(event) {
		bubble($$self, event);
	}

	function keypress_handler_11(event) {
		bubble($$self, event);
	}

	function keyup_handler_11(event) {
		bubble($$self, event);
	}

	function change_handler_11(event) {
		bubble($$self, event);
	}

	function input_handler_11(event) {
		bubble($$self, event);
	}

	function blur_handler_12(event) {
		bubble($$self, event);
	}

	function focus_handler_12(event) {
		bubble($$self, event);
	}

	function keydown_handler_12(event) {
		bubble($$self, event);
	}

	function keypress_handler_12(event) {
		bubble($$self, event);
	}

	function keyup_handler_12(event) {
		bubble($$self, event);
	}

	function change_handler_12(event) {
		bubble($$self, event);
	}

	function input_handler_12(event) {
		bubble($$self, event);
	}

	function blur_handler_13(event) {
		bubble($$self, event);
	}

	function focus_handler_13(event) {
		bubble($$self, event);
	}

	function keydown_handler_13(event) {
		bubble($$self, event);
	}

	function keypress_handler_13(event) {
		bubble($$self, event);
	}

	function keyup_handler_13(event) {
		bubble($$self, event);
	}

	function change_handler_13(event) {
		bubble($$self, event);
	}

	function input_handler_13(event) {
		bubble($$self, event);
	}

	function blur_handler_14(event) {
		bubble($$self, event);
	}

	function focus_handler_14(event) {
		bubble($$self, event);
	}

	function keydown_handler_14(event) {
		bubble($$self, event);
	}

	function keypress_handler_14(event) {
		bubble($$self, event);
	}

	function keyup_handler_14(event) {
		bubble($$self, event);
	}

	function blur_handler_15(event) {
		bubble($$self, event);
	}

	function focus_handler_15(event) {
		bubble($$self, event);
	}

	function keydown_handler_15(event) {
		bubble($$self, event);
	}

	function keypress_handler_15(event) {
		bubble($$self, event);
	}

	function keyup_handler_15(event) {
		bubble($$self, event);
	}

	function change_handler_14(event) {
		bubble($$self, event);
	}

	function input_handler_14(event) {
		bubble($$self, event);
	}

	function blur_handler_16(event) {
		bubble($$self, event);
	}

	function focus_handler_16(event) {
		bubble($$self, event);
	}

	function change_handler_15(event) {
		bubble($$self, event);
	}

	function input_handler_15(event) {
		bubble($$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_1() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_change_handler() {
		files = this.files;
		$$invalidate(2, files);
	}

	function input_change_handler_1() {
		checked = this.checked;
		value = this.value;
		$$invalidate(0, checked);
		$$invalidate(1, value);
	}

	function input_change_handler_2() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_3() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_4() {
		value = to_number(this.value);
		$$invalidate(1, value);
	}

	function input_input_handler_5() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_6() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_7() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_input_handler_8() {
		value = this.value;
		$$invalidate(1, value);
	}

	function input_change_input_handler() {
		value = to_number(this.value);
		$$invalidate(1, value);
	}

	function input_input_handler_9() {
		value = this.value;
		$$invalidate(1, value);
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(1, value);
	}

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(1, value);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(15, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("size" in $$new_props) $$invalidate(13, size = $$new_props.size);
		if ("bsSize" in $$new_props) $$invalidate(14, bsSize = $$new_props.bsSize);
		if ("color" in $$new_props) $$invalidate(16, color = $$new_props.color);
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("valid" in $$new_props) $$invalidate(17, valid = $$new_props.valid);
		if ("invalid" in $$new_props) $$invalidate(18, invalid = $$new_props.invalid);
		if ("plaintext" in $$new_props) $$invalidate(19, plaintext = $$new_props.plaintext);
		if ("addon" in $$new_props) $$invalidate(20, addon = $$new_props.addon);
		if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ("files" in $$new_props) $$invalidate(2, files = $$new_props.files);
		if ("readonly" in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("multiple" in $$new_props) $$invalidate(5, multiple = $$new_props.multiple);
		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ("placeholder" in $$new_props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
		if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		type,
		size,
		bsSize,
		color,
		checked,
		valid,
		invalid,
		plaintext,
		addon,
		value,
		files,
		readonly,
		multiple,
		name,
		placeholder,
		disabled,
		classes,
		tag,
		handleInput
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(15, className = $$new_props.className);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("size" in $$props) $$invalidate(13, size = $$new_props.size);
		if ("bsSize" in $$props) $$invalidate(14, bsSize = $$new_props.bsSize);
		if ("color" in $$props) $$invalidate(16, color = $$new_props.color);
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("valid" in $$props) $$invalidate(17, valid = $$new_props.valid);
		if ("invalid" in $$props) $$invalidate(18, invalid = $$new_props.invalid);
		if ("plaintext" in $$props) $$invalidate(19, plaintext = $$new_props.plaintext);
		if ("addon" in $$props) $$invalidate(20, addon = $$new_props.addon);
		if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
		if ("files" in $$props) $$invalidate(2, files = $$new_props.files);
		if ("readonly" in $$props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("multiple" in $$props) $$invalidate(5, multiple = $$new_props.multiple);
		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
		if ("placeholder" in $$props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
		if ("classes" in $$props) $$invalidate(9, classes = $$new_props.classes);
		if ("tag" in $$props) $$invalidate(10, tag = $$new_props.tag);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, plaintext, addon, color, size, className, invalid, valid, bsSize*/ 2088968) {
			$: {
				const checkInput = ["radio", "checkbox"].indexOf(type) > -1;
				const isNotaNumber = new RegExp("\\D", "g");
				const fileInput = type === "file";
				const textareaInput = type === "textarea";
				const rangeInput = type === "range";
				const selectInput = type === "select";
				const buttonInput = type === "button" || type === "reset" || type === "submit";
				const unsupportedInput = type === "hidden" || type === "image";
				$$invalidate(10, tag = selectInput || textareaInput ? type : "input");
				let formControlClass = "form-control";

				if (plaintext) {
					formControlClass = `${formControlClass}-plaintext`;
					$$invalidate(10, tag = "input");
				} else if (fileInput) {
					formControlClass = `${formControlClass}-file`;
				} else if (checkInput) {
					if (addon) {
						formControlClass = null;
					} else {
						formControlClass = "form-check-input";
					}
				} else if (buttonInput) {
					formControlClass = `btn btn-${color || "secondary"}`;
				} else if (rangeInput) {
					formControlClass = "form-control-range";
				} else if (unsupportedInput) {
					formControlClass = "";
				}

				if (size && isNotaNumber.test(size)) {
					console.warn("Please use the prop \"bsSize\" instead of the \"size\" to bootstrap's input sizing.");
					$$invalidate(14, bsSize = size);
					$$invalidate(13, size = undefined);
				}

				$$invalidate(9, classes = classnames(className, invalid && "is-invalid", valid && "is-valid", bsSize ? `form-control-${bsSize}` : false, formControlClass));
			}
		}
	};

	return [
		checked,
		value,
		files,
		type,
		readonly,
		multiple,
		name,
		placeholder,
		disabled,
		classes,
		tag,
		handleInput,
		$$restProps,
		size,
		bsSize,
		className,
		color,
		valid,
		invalid,
		plaintext,
		addon,
		$$scope,
		slots,
		blur_handler,
		focus_handler,
		keydown_handler,
		keypress_handler,
		keyup_handler,
		change_handler,
		input_handler,
		blur_handler_1,
		focus_handler_1,
		keydown_handler_1,
		keypress_handler_1,
		keyup_handler_1,
		change_handler_1,
		input_handler_1,
		blur_handler_2,
		focus_handler_2,
		keydown_handler_2,
		keypress_handler_2,
		keyup_handler_2,
		change_handler_2,
		input_handler_2,
		blur_handler_3,
		focus_handler_3,
		keydown_handler_3,
		keypress_handler_3,
		keyup_handler_3,
		change_handler_3,
		input_handler_3,
		blur_handler_4,
		focus_handler_4,
		keydown_handler_4,
		keypress_handler_4,
		keyup_handler_4,
		change_handler_4,
		input_handler_4,
		blur_handler_5,
		focus_handler_5,
		keydown_handler_5,
		keypress_handler_5,
		keyup_handler_5,
		change_handler_5,
		input_handler_5,
		blur_handler_6,
		focus_handler_6,
		keydown_handler_6,
		keypress_handler_6,
		keyup_handler_6,
		change_handler_6,
		input_handler_6,
		blur_handler_7,
		focus_handler_7,
		keydown_handler_7,
		keypress_handler_7,
		keyup_handler_7,
		change_handler_7,
		input_handler_7,
		blur_handler_8,
		focus_handler_8,
		keydown_handler_8,
		keypress_handler_8,
		keyup_handler_8,
		change_handler_8,
		input_handler_8,
		blur_handler_9,
		focus_handler_9,
		keydown_handler_9,
		keypress_handler_9,
		keyup_handler_9,
		change_handler_9,
		input_handler_9,
		blur_handler_10,
		focus_handler_10,
		keydown_handler_10,
		keypress_handler_10,
		keyup_handler_10,
		change_handler_10,
		input_handler_10,
		blur_handler_11,
		focus_handler_11,
		keydown_handler_11,
		keypress_handler_11,
		keyup_handler_11,
		change_handler_11,
		input_handler_11,
		blur_handler_12,
		focus_handler_12,
		keydown_handler_12,
		keypress_handler_12,
		keyup_handler_12,
		change_handler_12,
		input_handler_12,
		blur_handler_13,
		focus_handler_13,
		keydown_handler_13,
		keypress_handler_13,
		keyup_handler_13,
		change_handler_13,
		input_handler_13,
		blur_handler_14,
		focus_handler_14,
		keydown_handler_14,
		keypress_handler_14,
		keyup_handler_14,
		blur_handler_15,
		focus_handler_15,
		keydown_handler_15,
		keypress_handler_15,
		keyup_handler_15,
		change_handler_14,
		input_handler_14,
		blur_handler_16,
		focus_handler_16,
		change_handler_15,
		input_handler_15,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_change_handler,
		input_change_handler_1,
		input_change_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input_input_handler_5,
		input_input_handler_6,
		input_input_handler_7,
		input_input_handler_8,
		input_change_input_handler,
		input_input_handler_9,
		textarea_input_handler,
		select_change_handler
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$E,
			create_fragment$E,
			safe_not_equal,
			{
				class: 15,
				type: 3,
				size: 13,
				bsSize: 14,
				color: 16,
				checked: 0,
				valid: 17,
				invalid: 18,
				plaintext: 19,
				addon: 20,
				value: 1,
				files: 2,
				readonly: 4,
				multiple: 5,
				name: 6,
				placeholder: 7,
				disabled: 8
			},
			[-1, -1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$E.name
		});
	}

	get class() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bsSize() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bsSize(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get plaintext() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set plaintext(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addon() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addon(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get files() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set files(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/InputGroup.svelte generated by Svelte v3.37.0 */
const file$F = "node_modules/sveltestrap/src/InputGroup.svelte";

function create_fragment$F(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$F, 14, 0, 243);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$F($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","size"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InputGroup", slots, ['default']);
	let { class: className = "" } = $$props;
	let { size = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, size, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size*/ 12) {
			$: $$invalidate(0, classes = classnames(className, "input-group", size ? `input-group-${size}` : null));
		}
	};

	return [classes, $$restProps, className, size, $$scope, slots];
}

class InputGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$F, create_fragment$F, safe_not_equal, { class: 2, size: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InputGroup",
			options,
			id: create_fragment$F.name
		});
	}

	get class() {
		throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/InputGroupAddon.svelte generated by Svelte v3.37.0 */

const { Error: Error_1$1 } = globals;
const file$G = "node_modules/sveltestrap/src/InputGroupAddon.svelte";

function create_fragment$G(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$G, 16, 0, 385);
		},
		l: function claim(nodes) {
			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$G($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","addonType"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InputGroupAddon", slots, ['default']);
	let { class: className = "" } = $$props;
	let { addonType = "" } = $$props;

	if (["prepend", "append"].indexOf(addonType) === -1) {
		throw new Error(`addonType must be one of 'prepend', 'append'. Received '${addonType}' instead.`);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("addonType" in $$new_props) $$invalidate(3, addonType = $$new_props.addonType);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		addonType,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("addonType" in $$props) $$invalidate(3, addonType = $$new_props.addonType);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, addonType*/ 12) {
			$: $$invalidate(0, classes = classnames(className, `input-group-${addonType}`));
		}
	};

	return [classes, $$restProps, className, addonType, $$scope, slots];
}

class InputGroupAddon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$G, create_fragment$G, safe_not_equal, { class: 2, addonType: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InputGroupAddon",
			options,
			id: create_fragment$G.name
		});
	}

	get class() {
		throw new Error_1$1("<InputGroupAddon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$1("<InputGroupAddon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addonType() {
		throw new Error_1$1("<InputGroupAddon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addonType(value) {
		throw new Error_1$1("<InputGroupAddon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/InputGroupButtonDropdown.svelte generated by Svelte v3.37.0 */

const { Error: Error_1$2 } = globals;
const file$H = "node_modules/sveltestrap/src/InputGroupButtonDropdown.svelte";

// (17:0) <Dropdown {...$$restProps} class={className} {addonType} {toggle} {isOpen}>
function create_default_slot$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(17:0) <Dropdown {...$$restProps} class={className} {addonType} {toggle} {isOpen}>",
		ctx
	});

	return block;
}

function create_fragment$H(ctx) {
	let dropdown;
	let current;

	const dropdown_spread_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*className*/ ctx[0] },
		{ addonType: /*addonType*/ ctx[1] },
		{ toggle: /*toggle*/ ctx[2] },
		{ isOpen: /*isOpen*/ ctx[3] }
	];

	let dropdown_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
		dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
	}

	dropdown = new Dropdown({ props: dropdown_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(dropdown.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dropdown, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dropdown_changes = (dirty & /*$$restProps, className, addonType, toggle, isOpen*/ 31)
			? get_spread_update(dropdown_spread_levels, [
					dirty & /*$$restProps*/ 16 && get_spread_object(/*$$restProps*/ ctx[4]),
					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] },
					dirty & /*addonType*/ 2 && { addonType: /*addonType*/ ctx[1] },
					dirty & /*toggle*/ 4 && { toggle: /*toggle*/ ctx[2] },
					dirty & /*isOpen*/ 8 && { isOpen: /*isOpen*/ ctx[3] }
				])
			: {};

			if (dirty & /*$$scope*/ 64) {
				dropdown_changes.$$scope = { dirty, ctx };
			}

			dropdown.$set(dropdown_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dropdown, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$H($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","addonType","toggle","isOpen"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InputGroupButtonDropdown", slots, ['default']);
	let { class: className = "" } = $$props;
	let { addonType } = $$props;
	let { toggle } = $$props;
	let { isOpen } = $$props;

	if (["prepend", "append"].indexOf(addonType) === -1) {
		throw new Error(`addonType must be one of 'prepend', 'append'. Received '${addonType}' instead.`);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("addonType" in $$new_props) $$invalidate(1, addonType = $$new_props.addonType);
		if ("toggle" in $$new_props) $$invalidate(2, toggle = $$new_props.toggle);
		if ("isOpen" in $$new_props) $$invalidate(3, isOpen = $$new_props.isOpen);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Dropdown,
		className,
		addonType,
		toggle,
		isOpen
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("addonType" in $$props) $$invalidate(1, addonType = $$new_props.addonType);
		if ("toggle" in $$props) $$invalidate(2, toggle = $$new_props.toggle);
		if ("isOpen" in $$props) $$invalidate(3, isOpen = $$new_props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [className, addonType, toggle, isOpen, $$restProps, slots, $$scope];
}

class InputGroupButtonDropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
			class: 0,
			addonType: 1,
			toggle: 2,
			isOpen: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InputGroupButtonDropdown",
			options,
			id: create_fragment$H.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*addonType*/ ctx[1] === undefined && !("addonType" in props)) {
			console.warn("<InputGroupButtonDropdown> was created without expected prop 'addonType'");
		}

		if (/*toggle*/ ctx[2] === undefined && !("toggle" in props)) {
			console.warn("<InputGroupButtonDropdown> was created without expected prop 'toggle'");
		}

		if (/*isOpen*/ ctx[3] === undefined && !("isOpen" in props)) {
			console.warn("<InputGroupButtonDropdown> was created without expected prop 'isOpen'");
		}
	}

	get class() {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addonType() {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addonType(value) {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error_1$2("<InputGroupButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/InputGroupText.svelte generated by Svelte v3.37.0 */
const file$I = "node_modules/sveltestrap/src/InputGroupText.svelte";

function create_fragment$I(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let span_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$I, 9, 0, 171);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$I($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InputGroupText", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "input-group-text"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class InputGroupText extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$I, create_fragment$I, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InputGroupText",
			options,
			id: create_fragment$I.name
		});
	}

	get class() {
		throw new Error("<InputGroupText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<InputGroupText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Jumbotron.svelte generated by Svelte v3.37.0 */
const file$J = "node_modules/sveltestrap/src/Jumbotron.svelte";

// (20:0) {:else}
function create_else_block$c(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$J, 20, 2, 374);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$c.name,
		type: "else",
		source: "(20:0) {:else}",
		ctx
	});

	return block;
}

// (16:0) {#if tag === 'section'}
function create_if_block$e(ctx) {
	let section;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let section_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let section_data = {};

	for (let i = 0; i < section_levels.length; i += 1) {
		section_data = assign(section_data, section_levels[i]);
	}

	const block = {
		c: function create() {
			section = element("section");
			if (default_slot) default_slot.c();
			set_attributes(section, section_data);
			add_location(section, file$J, 16, 2, 295);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);

			if (default_slot) {
				default_slot.m(section, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(section, section_data = get_spread_update(section_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(16:0) {#if tag === 'section'}",
		ctx
	});

	return block;
}

function create_fragment$J(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$e, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "section") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$J($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","fluid","tag"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Jumbotron", slots, ['default']);
	let { class: className = "" } = $$props;
	let { fluid = false } = $$props;
	let { tag = "div" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("fluid" in $$new_props) $$invalidate(4, fluid = $$new_props.fluid);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		fluid,
		tag,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("fluid" in $$props) $$invalidate(4, fluid = $$new_props.fluid);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, fluid*/ 24) {
			$: $$invalidate(1, classes = classnames(className, "jumbotron", fluid ? "jumbotron-fluid" : false));
		}
	};

	return [tag, classes, $$restProps, className, fluid, $$scope, slots];
}

class Jumbotron extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$J, create_fragment$J, safe_not_equal, { class: 3, fluid: 4, tag: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Jumbotron",
			options,
			id: create_fragment$J.name
		});
	}

	get class() {
		throw new Error("<Jumbotron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Jumbotron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fluid() {
		throw new Error("<Jumbotron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fluid(value) {
		throw new Error("<Jumbotron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Jumbotron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Jumbotron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Label.svelte generated by Svelte v3.37.0 */
const file$K = "node_modules/sveltestrap/src/Label.svelte";

function create_fragment$K(ctx) {
	let label;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let label_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ for: /*fore*/ ctx[0] }
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			set_attributes(label, label_data);
			add_location(label, file$K, 69, 0, 1625);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*fore*/ 1) && { for: /*fore*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$K($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","hidden","check","size","for","xs","sm","md","lg","xl","widths"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Label", slots, ['default']);
	let { class: className = "" } = $$props;
	let { hidden = false } = $$props;
	let { check = false } = $$props;
	let { size = "" } = $$props;
	let { for: fore = null } = $$props;
	let { xs = "" } = $$props;
	let { sm = "" } = $$props;
	let { md = "" } = $$props;
	let { lg = "" } = $$props;
	let { xl = "" } = $$props;
	const colWidths = { xs, sm, md, lg, xl };
	let { widths = Object.keys(colWidths) } = $$props;
	const colClasses = [];

	widths.forEach(colWidth => {
		let columnProp = $$props[colWidth];

		if (!columnProp && columnProp !== "") {
			return;
		}

		const isXs = colWidth === "xs";
		let colClass;

		if (isObject(columnProp)) {
			const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
			colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

			colClasses.push(classnames({
				[colClass]: columnProp.size || columnProp.size === "",
				[`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
				[`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
			}));
		} else {
			colClass = getColumnSizeClass(isXs, colWidth, columnProp);
			colClasses.push(colClass);
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("hidden" in $$new_props) $$invalidate(4, hidden = $$new_props.hidden);
		if ("check" in $$new_props) $$invalidate(5, check = $$new_props.check);
		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
		if ("for" in $$new_props) $$invalidate(0, fore = $$new_props.for);
		if ("xs" in $$new_props) $$invalidate(7, xs = $$new_props.xs);
		if ("sm" in $$new_props) $$invalidate(8, sm = $$new_props.sm);
		if ("md" in $$new_props) $$invalidate(9, md = $$new_props.md);
		if ("lg" in $$new_props) $$invalidate(10, lg = $$new_props.lg);
		if ("xl" in $$new_props) $$invalidate(11, xl = $$new_props.xl);
		if ("widths" in $$new_props) $$invalidate(12, widths = $$new_props.widths);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		getColumnSizeClass,
		isObject,
		className,
		hidden,
		check,
		size,
		fore,
		xs,
		sm,
		md,
		lg,
		xl,
		colWidths,
		widths,
		colClasses,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("hidden" in $$props) $$invalidate(4, hidden = $$new_props.hidden);
		if ("check" in $$props) $$invalidate(5, check = $$new_props.check);
		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
		if ("fore" in $$props) $$invalidate(0, fore = $$new_props.fore);
		if ("xs" in $$props) $$invalidate(7, xs = $$new_props.xs);
		if ("sm" in $$props) $$invalidate(8, sm = $$new_props.sm);
		if ("md" in $$props) $$invalidate(9, md = $$new_props.md);
		if ("lg" in $$props) $$invalidate(10, lg = $$new_props.lg);
		if ("xl" in $$props) $$invalidate(11, xl = $$new_props.xl);
		if ("widths" in $$props) $$invalidate(12, widths = $$new_props.widths);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, hidden, check, size*/ 120) {
			$: $$invalidate(1, classes = classnames(className, hidden ? "sr-only" : false, check ? "form-check-label" : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? "col-form-label" : false));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		fore,
		classes,
		$$restProps,
		className,
		hidden,
		check,
		size,
		xs,
		sm,
		md,
		lg,
		xl,
		widths,
		$$scope,
		slots
	];
}

class Label extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
			class: 3,
			hidden: 4,
			check: 5,
			size: 6,
			for: 0,
			xs: 7,
			sm: 8,
			md: 9,
			lg: 10,
			xl: 11,
			widths: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Label",
			options,
			id: create_fragment$K.name
		});
	}

	get class() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hidden() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hidden(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get check() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set check(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get for() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set for(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xs() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xs(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sm() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sm(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get md() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set md(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lg() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lg(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xl() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xl(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get widths() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set widths(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ListGroup.svelte generated by Svelte v3.37.0 */
const file$L = "node_modules/sveltestrap/src/ListGroup.svelte";

function create_fragment$L(ctx) {
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let ul_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = assign(ul_data, ul_levels[i]);
	}

	const block = {
		c: function create() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			set_attributes(ul, ul_data);
			add_location(ul, file$L, 14, 0, 245);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$L($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","flush"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ListGroup", slots, ['default']);
	let { class: className = "" } = $$props;
	let { flush = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("flush" in $$new_props) $$invalidate(3, flush = $$new_props.flush);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, flush, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("flush" in $$props) $$invalidate(3, flush = $$new_props.flush);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, flush*/ 12) {
			$: $$invalidate(0, classes = classnames(className, "list-group", flush ? "list-group-flush" : false));
		}
	};

	return [classes, $$restProps, className, flush, $$scope, slots];
}

class ListGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$L, create_fragment$L, safe_not_equal, { class: 2, flush: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ListGroup",
			options,
			id: create_fragment$L.name
		});
	}

	get class() {
		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flush() {
		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flush(value) {
		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ListGroupItem.svelte generated by Svelte v3.37.0 */
const file$M = "node_modules/sveltestrap/src/ListGroupItem.svelte";

// (37:0) {:else}
function create_else_block$d(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let li_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ disabled: /*disabled*/ ctx[1] },
		{ active: /*active*/ ctx[0] }
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$M, 37, 2, 779);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty & /*disabled*/ 2) && { disabled: /*disabled*/ ctx[1] },
				(!current || dirty & /*active*/ 1) && { active: /*active*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$d.name,
		type: "else",
		source: "(37:0) {:else}",
		ctx
	});

	return block;
}

// (27:27) 
function create_if_block_1$7(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let button_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ type: "button" },
		{ disabled: /*disabled*/ ctx[1] },
		{ active: /*active*/ ctx[0] }
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$M, 27, 2, 635);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				{ type: "button" },
				(!current || dirty & /*disabled*/ 2) && { disabled: /*disabled*/ ctx[1] },
				(!current || dirty & /*active*/ 1) && { active: /*active*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(27:27) ",
		ctx
	});

	return block;
}

// (23:0) {#if href}
function create_if_block$f(ctx) {
	let a;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let a_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ href: /*href*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[1] },
		{ active: /*active*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$M, 23, 2, 521);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
				(!current || dirty & /*disabled*/ 2) && { disabled: /*disabled*/ ctx[1] },
				(!current || dirty & /*active*/ 1) && { active: /*active*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$f.name,
		type: "if",
		source: "(23:0) {#if href}",
		ctx
	});

	return block;
}

function create_fragment$M(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$f, create_if_block_1$7, create_else_block$d];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[2]) return 0;
		if (/*tag*/ ctx[3] === "button") return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$M($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled","color","action","href","tag"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ListGroupItem", slots, ['default']);
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { color = "" } = $$props;
	let { action = false } = $$props;
	let { href = null } = $$props;
	let { tag = null } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(0, active = $$new_props.active);
		if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("color" in $$new_props) $$invalidate(7, color = $$new_props.color);
		if ("action" in $$new_props) $$invalidate(8, action = $$new_props.action);
		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
		if ("tag" in $$new_props) $$invalidate(3, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		active,
		disabled,
		color,
		action,
		href,
		tag,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(0, active = $$new_props.active);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("color" in $$props) $$invalidate(7, color = $$new_props.color);
		if ("action" in $$props) $$invalidate(8, action = $$new_props.action);
		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
		if ("tag" in $$props) $$invalidate(3, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active, disabled, action, color*/ 451) {
			$: $$invalidate(4, classes = classnames(className, active ? "active" : false, disabled ? "disabled" : false, action ? "list-group-item-action" : false, color ? `list-group-item-${color}` : false, "list-group-item"));
		}
	};

	return [
		active,
		disabled,
		href,
		tag,
		classes,
		$$restProps,
		className,
		color,
		action,
		$$scope,
		slots,
		click_handler
	];
}

class ListGroupItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$M, create_fragment$M, safe_not_equal, {
			class: 6,
			active: 0,
			disabled: 1,
			color: 7,
			action: 8,
			href: 2,
			tag: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ListGroupItem",
			options,
			id: create_fragment$M.name
		});
	}

	get class() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get action() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set action(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Media.svelte generated by Svelte v3.37.0 */
const file$N = "node_modules/sveltestrap/src/Media.svelte";

// (56:0) {:else}
function create_else_block$e(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	let div_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[6] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$N, 56, 2, 1190);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$e.name,
		type: "else",
		source: "(56:0) {:else}",
		ctx
	});

	return block;
}

// (52:15) 
function create_if_block_3$3(ctx) {
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	let ul_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[6] }];
	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = assign(ul_data, ul_levels[i]);
	}

	const block = {
		c: function create() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			set_attributes(ul, ul_data);
			add_location(ul, file$N, 52, 2, 1121);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(52:15) ",
		ctx
	});

	return block;
}

// (50:24) 
function create_if_block_2$6(ctx) {
	let img;
	let img_src_value;

	let img_levels = [
		/*$$restProps*/ ctx[7],
		{ class: /*classes*/ ctx[6] },
		{ src: img_src_value = /*src*/ ctx[4] },
		{ alt: /*alt*/ ctx[5] }
	];

	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = assign(img_data, img_levels[i]);
	}

	const block = {
		c: function create() {
			img = element("img");
			set_attributes(img, img_data);
			add_location(img, file$N, 50, 2, 1050);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			set_attributes(img, img_data = get_spread_update(img_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				dirty & /*classes*/ 64 && { class: /*classes*/ ctx[6] },
				dirty & /*src*/ 16 && img.src !== (img_src_value = /*src*/ ctx[4]) && { src: img_src_value },
				dirty & /*alt*/ 32 && { alt: /*alt*/ ctx[5] }
			]));
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(50:24) ",
		ctx
	});

	return block;
}

// (46:15) 
function create_if_block_1$8(ctx) {
	let a;
	let current;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let a_levels = [
		/*$$restProps*/ ctx[7],
		{ class: /*classes*/ ctx[6] },
		{ href: /*href*/ ctx[3] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$N, 46, 2, 959);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(46:15) ",
		ctx
	});

	return block;
}

// (42:0) {#if heading}
function create_if_block$g(ctx) {
	let h4;
	let current;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	let h4_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[6] }];
	let h4_data = {};

	for (let i = 0; i < h4_levels.length; i += 1) {
		h4_data = assign(h4_data, h4_levels[i]);
	}

	const block = {
		c: function create() {
			h4 = element("h4");
			if (default_slot) default_slot.c();
			set_attributes(h4, h4_data);
			add_location(h4, file$N, 42, 2, 882);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);

			if (default_slot) {
				default_slot.m(h4, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			set_attributes(h4, h4_data = get_spread_update(h4_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$g.name,
		type: "if",
		source: "(42:0) {#if heading}",
		ctx
	});

	return block;
}

function create_fragment$N(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block$g,
		create_if_block_1$8,
		create_if_block_2$6,
		create_if_block_3$3,
		create_else_block$e
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*heading*/ ctx[0]) return 0;
		if (/*href*/ ctx[3]) return 1;
		if (/*src*/ ctx[4] || /*object*/ ctx[2]) return 2;
		if (/*list*/ ctx[1]) return 3;
		return 4;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$N($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","body","bottom","heading","left","list","middle","object","right","top","href","src","alt"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Media", slots, ['default']);
	let { class: className = "" } = $$props;
	let { body = false } = $$props;
	let { bottom = false } = $$props;
	let { heading = false } = $$props;
	let { left = false } = $$props;
	let { list = false } = $$props;
	let { middle = false } = $$props;
	let { object = false } = $$props;
	let { right = false } = $$props;
	let { top = false } = $$props;
	let { href = "" } = $$props;
	let { src = "" } = $$props;
	let { alt = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("body" in $$new_props) $$invalidate(9, body = $$new_props.body);
		if ("bottom" in $$new_props) $$invalidate(10, bottom = $$new_props.bottom);
		if ("heading" in $$new_props) $$invalidate(0, heading = $$new_props.heading);
		if ("left" in $$new_props) $$invalidate(11, left = $$new_props.left);
		if ("list" in $$new_props) $$invalidate(1, list = $$new_props.list);
		if ("middle" in $$new_props) $$invalidate(12, middle = $$new_props.middle);
		if ("object" in $$new_props) $$invalidate(2, object = $$new_props.object);
		if ("right" in $$new_props) $$invalidate(13, right = $$new_props.right);
		if ("top" in $$new_props) $$invalidate(14, top = $$new_props.top);
		if ("href" in $$new_props) $$invalidate(3, href = $$new_props.href);
		if ("src" in $$new_props) $$invalidate(4, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(5, alt = $$new_props.alt);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		body,
		bottom,
		heading,
		left,
		list,
		middle,
		object,
		right,
		top,
		href,
		src,
		alt,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("body" in $$props) $$invalidate(9, body = $$new_props.body);
		if ("bottom" in $$props) $$invalidate(10, bottom = $$new_props.bottom);
		if ("heading" in $$props) $$invalidate(0, heading = $$new_props.heading);
		if ("left" in $$props) $$invalidate(11, left = $$new_props.left);
		if ("list" in $$props) $$invalidate(1, list = $$new_props.list);
		if ("middle" in $$props) $$invalidate(12, middle = $$new_props.middle);
		if ("object" in $$props) $$invalidate(2, object = $$new_props.object);
		if ("right" in $$props) $$invalidate(13, right = $$new_props.right);
		if ("top" in $$props) $$invalidate(14, top = $$new_props.top);
		if ("href" in $$props) $$invalidate(3, href = $$new_props.href);
		if ("src" in $$props) $$invalidate(4, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(5, alt = $$new_props.alt);
		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, body, heading, left, right, top, bottom, middle, object, list*/ 32519) {
			$: $$invalidate(6, classes = classnames(className, {
				"media-body": body,
				"media-heading": heading,
				"media-left": left,
				"media-right": right,
				"media-top": top,
				"media-bottom": bottom,
				"media-middle": middle,
				"media-object": object,
				"media-list": list,
				media: !body && !heading && !left && !right && !top && !bottom && !middle && !object && !list
			}));
		}
	};

	return [
		heading,
		list,
		object,
		href,
		src,
		alt,
		classes,
		$$restProps,
		className,
		body,
		bottom,
		left,
		middle,
		right,
		top,
		$$scope,
		slots
	];
}

class Media extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
			class: 8,
			body: 9,
			bottom: 10,
			heading: 0,
			left: 11,
			list: 1,
			middle: 12,
			object: 2,
			right: 13,
			top: 14,
			href: 3,
			src: 4,
			alt: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Media",
			options,
			id: create_fragment$N.name
		});
	}

	get class() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get body() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set body(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get heading() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set heading(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set left(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get middle() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set middle(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get object() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set object(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get src() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Modal.svelte generated by Svelte v3.37.0 */

const file$O = "node_modules/sveltestrap/src/Modal.svelte";
const get_external_slot_changes = dirty => ({});
const get_external_slot_context = ctx => ({});

// (217:0) {#if _isMounted}
function create_if_block$h(ctx) {
	let div;
	let current;
	let if_block = /*isOpen*/ ctx[1] && create_if_block_1$9(ctx);

	let div_levels = [
		{ class: /*wrapClassName*/ ctx[4] },
		{ tabindex: "-1" },
		/*$$restProps*/ ctx[18]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$O, 217, 2, 4706);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*isOpen*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*isOpen*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*wrapClassName*/ 16) && { class: /*wrapClassName*/ ctx[4] },
				{ tabindex: "-1" },
				dirty[0] & /*$$restProps*/ 262144 && /*$$restProps*/ ctx[18]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$h.name,
		type: "if",
		source: "(217:0) {#if _isMounted}",
		ctx
	});

	return block;
}

// (222:4) {#if isOpen}
function create_if_block_1$9(ctx) {
	let div2;
	let div1;
	let div0;
	let t0;
	let div0_class_value;
	let div2_class_value;
	let div2_transition;
	let t1;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	const external_slot_template = /*#slots*/ ctx[33].external;
	const external_slot = create_slot(external_slot_template, ctx, /*$$scope*/ ctx[32], get_external_slot_context);
	const default_slot_template = /*#slots*/ ctx[33].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);
	let if_block = /*backdrop*/ ctx[3] && !/*staticModal*/ ctx[0] && create_if_block_2$7(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (external_slot) external_slot.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(div0, "class", div0_class_value = classnames("modal-content", /*contentClassName*/ ctx[7]));
			add_location(div0, file$O, 237, 10, 5340);
			attr_dev(div1, "class", /*classes*/ ctx[13]);
			attr_dev(div1, "role", "document");
			add_location(div1, file$O, 236, 8, 5272);
			attr_dev(div2, "arialabelledby", /*labelledBy*/ ctx[2]);

			attr_dev(div2, "class", div2_class_value = classnames("modal", /*modalClassName*/ ctx[5], {
				show: /*isOpen*/ ctx[1],
				"d-block": /*isOpen*/ ctx[1],
				"d-none": !/*isOpen*/ ctx[1],
				"position-static": /*staticModal*/ ctx[0]
			}));

			attr_dev(div2, "role", "dialog");
			add_location(div2, file$O, 222, 6, 4800);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);

			if (external_slot) {
				external_slot.m(div0, null);
			}

			append_dev(div0, t0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[34](div1);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div2, "introend", /*onModalOpened*/ ctx[15], false, false, false),
					listen_dev(div2, "outroend", /*onModalClosed*/ ctx[16], false, false, false),
					listen_dev(div2, "click", /*handleBackdropClick*/ ctx[14], false, false, false),
					listen_dev(div2, "mousedown", /*handleBackdropMouseDown*/ ctx[17], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (external_slot) {
				if (external_slot.p && dirty[1] & /*$$scope*/ 2) {
					update_slot(external_slot, external_slot_template, ctx, /*$$scope*/ ctx[32], dirty, get_external_slot_changes, get_external_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[32], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*contentClassName*/ 128 && div0_class_value !== (div0_class_value = classnames("modal-content", /*contentClassName*/ ctx[7]))) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*classes*/ 8192) {
				attr_dev(div1, "class", /*classes*/ ctx[13]);
			}

			if (!current || dirty[0] & /*labelledBy*/ 4) {
				attr_dev(div2, "arialabelledby", /*labelledBy*/ ctx[2]);
			}

			if (!current || dirty[0] & /*modalClassName, isOpen, staticModal*/ 35 && div2_class_value !== (div2_class_value = classnames("modal", /*modalClassName*/ ctx[5], {
				show: /*isOpen*/ ctx[1],
				"d-block": /*isOpen*/ ctx[1],
				"d-none": !/*isOpen*/ ctx[1],
				"position-static": /*staticModal*/ ctx[0]
			}))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (/*backdrop*/ ctx[3] && !/*staticModal*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*backdrop, staticModal*/ 9) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(external_slot, local);
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, /*transitionType*/ ctx[9], /*transitionOptions*/ ctx[10], true);
				div2_transition.run(1);
			});

			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(external_slot, local);
			transition_out(default_slot, local);
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, /*transitionType*/ ctx[9], /*transitionOptions*/ ctx[10], false);
			div2_transition.run(0);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (external_slot) external_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[34](null);
			if (detaching && div2_transition) div2_transition.end();
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(222:4) {#if isOpen}",
		ctx
	});

	return block;
}

// (244:6) {#if backdrop && !staticModal}
function create_if_block_2$7(ctx) {
	let div;
	let div_class_value;
	let div_transition;
	let current;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", div_class_value = classnames("modal-backdrop", "show", /*backdropClassName*/ ctx[6]));
			add_location(div, file$O, 244, 8, 5548);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*backdropClassName*/ 64 && div_class_value !== (div_class_value = classnames("modal-backdrop", "show", /*backdropClassName*/ ctx[6]))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: /*backdropDuration*/ ctx[8] }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: /*backdropDuration*/ ctx[8] }, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$7.name,
		type: "if",
		source: "(244:6) {#if backdrop && !staticModal}",
		ctx
	});

	return block;
}

function create_fragment$O(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*_isMounted*/ ctx[11] && create_if_block$h(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*_isMounted*/ ctx[11]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*_isMounted*/ 2048) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$h(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let openCount = 0;
const dialogBaseClass = "modal-dialog";

function noop() {
	
}

function instance$O($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","static","isOpen","autoFocus","centered","scrollable","size","toggle","labelledBy","backdrop","onEnter","onExit","onOpened","onClosed","wrapClassName","modalClassName","backdropClassName","contentClassName","fade","backdropDuration","unmountOnClose","returnFocusAfterClose","transitionType","transitionOptions"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Modal", slots, ['external','default']);
	let { class: className = "" } = $$props;
	let { static: staticModal = false } = $$props;
	let { isOpen = false } = $$props;
	let { autoFocus = true } = $$props;
	let { centered = false } = $$props;
	let { scrollable = false } = $$props;
	let { size = "" } = $$props;
	let { toggle = undefined } = $$props;
	let { labelledBy = "" } = $$props;
	let { backdrop = true } = $$props;
	let { onEnter = undefined } = $$props;
	let { onExit = undefined } = $$props;
	let { onOpened = noop } = $$props;
	let { onClosed = noop } = $$props;
	let { wrapClassName = "" } = $$props;
	let { modalClassName = "" } = $$props;
	let { backdropClassName = "" } = $$props;
	let { contentClassName = "" } = $$props;
	let { fade: fade$1 = true } = $$props;
	let { backdropDuration = fade$1 ? 150 : 0 } = $$props;
	let { unmountOnClose = true } = $$props;
	let { returnFocusAfterClose = true } = $$props;
	let { transitionType = fade } = $$props;
	let { transitionOptions = { duration: fade$1 ? 300 : 0 } } = $$props;
	let hasOpened = false;
	let _isMounted = false;
	let _triggeringElement;
	let _originalBodyPadding;
	let _lastIsOpen = isOpen;
	let _lastHasOpened = hasOpened;
	let _dialog;
	let _mouseDownElement;
	let _removeEscListener;

	onMount(() => {
		if (isOpen) {
			init();
			hasOpened = true;
		}

		if (typeof onEnter === "function") {
			onEnter();
		}

		if (hasOpened && autoFocus) {
			setFocus();
		}
	});

	onDestroy(() => {
		if (typeof onExit === "function") {
			onExit();
		}

		destroy();

		if (hasOpened) {
			close();
		}
	});

	afterUpdate(() => {
		if (isOpen && !_lastIsOpen) {
			init();
			hasOpened = true;
		}

		if (autoFocus && hasOpened && !_lastHasOpened) {
			setFocus();
		}

		_lastIsOpen = isOpen;
		_lastHasOpened = hasOpened;
	});

	function setFocus() {
		if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === "function") {
			_dialog.parentNode.focus();
		}
	}

	function init() {
		try {
			_triggeringElement = document.activeElement;
		} catch(err) {
			_triggeringElement = null;
		}

		if (!staticModal) {
			_originalBodyPadding = getOriginalBodyPadding();
			conditionallyUpdateScrollbar();

			if (openCount === 0) {
				document.body.className = classnames(document.body.className, "modal-open");
			}

			++openCount;
		}

		$$invalidate(11, _isMounted = true);
	}

	function manageFocusAfterClose() {
		if (_triggeringElement) {
			if (typeof _triggeringElement.focus === "function" && returnFocusAfterClose) {
				_triggeringElement.focus();
			}

			_triggeringElement = null;
		}
	}

	function destroy() {
		manageFocusAfterClose();
	}

	function close() {
		if (openCount <= 1) {
			const modalOpenClassName = "modal-open";
			const modalOpenClassNameRegex = new RegExp(`(^| )${modalOpenClassName}( |$)`);
			document.body.className = document.body.className.replace(modalOpenClassNameRegex, " ").trim();
		}

		manageFocusAfterClose();
		openCount = Math.max(0, openCount - 1);
		setScrollbarWidth(_originalBodyPadding);
	}

	function handleBackdropClick(e) {
		if (e.target === _mouseDownElement) {
			e.stopPropagation();

			if (!isOpen || !backdrop) {
				return;
			}

			const backdropElem = _dialog ? _dialog.parentNode : null;

			if (backdropElem && e.target === backdropElem && toggle) {
				toggle(e);
			}
		}
	}

	function onModalOpened() {
		_removeEscListener = browserEvent(document, "keydown", event => {
			if (event.key && event.key === "Escape") {
				toggle(event);
			}
		});

		onOpened();
	}

	function onModalClosed() {
		onClosed();

		if (_removeEscListener) {
			_removeEscListener();
		}

		if (unmountOnClose) {
			destroy();
		}

		close();

		if (_isMounted) {
			hasOpened = false;
		}

		$$invalidate(11, _isMounted = false);
	}

	function handleBackdropMouseDown(e) {
		_mouseDownElement = e.target;
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			_dialog = $$value;
			$$invalidate(12, _dialog);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("static" in $$new_props) $$invalidate(0, staticModal = $$new_props.static);
		if ("isOpen" in $$new_props) $$invalidate(1, isOpen = $$new_props.isOpen);
		if ("autoFocus" in $$new_props) $$invalidate(20, autoFocus = $$new_props.autoFocus);
		if ("centered" in $$new_props) $$invalidate(21, centered = $$new_props.centered);
		if ("scrollable" in $$new_props) $$invalidate(22, scrollable = $$new_props.scrollable);
		if ("size" in $$new_props) $$invalidate(23, size = $$new_props.size);
		if ("toggle" in $$new_props) $$invalidate(24, toggle = $$new_props.toggle);
		if ("labelledBy" in $$new_props) $$invalidate(2, labelledBy = $$new_props.labelledBy);
		if ("backdrop" in $$new_props) $$invalidate(3, backdrop = $$new_props.backdrop);
		if ("onEnter" in $$new_props) $$invalidate(25, onEnter = $$new_props.onEnter);
		if ("onExit" in $$new_props) $$invalidate(26, onExit = $$new_props.onExit);
		if ("onOpened" in $$new_props) $$invalidate(27, onOpened = $$new_props.onOpened);
		if ("onClosed" in $$new_props) $$invalidate(28, onClosed = $$new_props.onClosed);
		if ("wrapClassName" in $$new_props) $$invalidate(4, wrapClassName = $$new_props.wrapClassName);
		if ("modalClassName" in $$new_props) $$invalidate(5, modalClassName = $$new_props.modalClassName);
		if ("backdropClassName" in $$new_props) $$invalidate(6, backdropClassName = $$new_props.backdropClassName);
		if ("contentClassName" in $$new_props) $$invalidate(7, contentClassName = $$new_props.contentClassName);
		if ("fade" in $$new_props) $$invalidate(29, fade$1 = $$new_props.fade);
		if ("backdropDuration" in $$new_props) $$invalidate(8, backdropDuration = $$new_props.backdropDuration);
		if ("unmountOnClose" in $$new_props) $$invalidate(30, unmountOnClose = $$new_props.unmountOnClose);
		if ("returnFocusAfterClose" in $$new_props) $$invalidate(31, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
		if ("transitionType" in $$new_props) $$invalidate(9, transitionType = $$new_props.transitionType);
		if ("transitionOptions" in $$new_props) $$invalidate(10, transitionOptions = $$new_props.transitionOptions);
		if ("$$scope" in $$new_props) $$invalidate(32, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		openCount,
		classnames,
		browserEvent,
		onDestroy,
		onMount,
		afterUpdate,
		fadeTransition: fade,
		conditionallyUpdateScrollbar,
		getOriginalBodyPadding,
		setScrollbarWidth,
		noop,
		className,
		staticModal,
		isOpen,
		autoFocus,
		centered,
		scrollable,
		size,
		toggle,
		labelledBy,
		backdrop,
		onEnter,
		onExit,
		onOpened,
		onClosed,
		wrapClassName,
		modalClassName,
		backdropClassName,
		contentClassName,
		fade: fade$1,
		backdropDuration,
		unmountOnClose,
		returnFocusAfterClose,
		transitionType,
		transitionOptions,
		hasOpened,
		_isMounted,
		_triggeringElement,
		_originalBodyPadding,
		_lastIsOpen,
		_lastHasOpened,
		_dialog,
		_mouseDownElement,
		_removeEscListener,
		setFocus,
		init,
		manageFocusAfterClose,
		destroy,
		close,
		handleBackdropClick,
		onModalOpened,
		onModalClosed,
		handleBackdropMouseDown,
		dialogBaseClass,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("staticModal" in $$props) $$invalidate(0, staticModal = $$new_props.staticModal);
		if ("isOpen" in $$props) $$invalidate(1, isOpen = $$new_props.isOpen);
		if ("autoFocus" in $$props) $$invalidate(20, autoFocus = $$new_props.autoFocus);
		if ("centered" in $$props) $$invalidate(21, centered = $$new_props.centered);
		if ("scrollable" in $$props) $$invalidate(22, scrollable = $$new_props.scrollable);
		if ("size" in $$props) $$invalidate(23, size = $$new_props.size);
		if ("toggle" in $$props) $$invalidate(24, toggle = $$new_props.toggle);
		if ("labelledBy" in $$props) $$invalidate(2, labelledBy = $$new_props.labelledBy);
		if ("backdrop" in $$props) $$invalidate(3, backdrop = $$new_props.backdrop);
		if ("onEnter" in $$props) $$invalidate(25, onEnter = $$new_props.onEnter);
		if ("onExit" in $$props) $$invalidate(26, onExit = $$new_props.onExit);
		if ("onOpened" in $$props) $$invalidate(27, onOpened = $$new_props.onOpened);
		if ("onClosed" in $$props) $$invalidate(28, onClosed = $$new_props.onClosed);
		if ("wrapClassName" in $$props) $$invalidate(4, wrapClassName = $$new_props.wrapClassName);
		if ("modalClassName" in $$props) $$invalidate(5, modalClassName = $$new_props.modalClassName);
		if ("backdropClassName" in $$props) $$invalidate(6, backdropClassName = $$new_props.backdropClassName);
		if ("contentClassName" in $$props) $$invalidate(7, contentClassName = $$new_props.contentClassName);
		if ("fade" in $$props) $$invalidate(29, fade$1 = $$new_props.fade);
		if ("backdropDuration" in $$props) $$invalidate(8, backdropDuration = $$new_props.backdropDuration);
		if ("unmountOnClose" in $$props) $$invalidate(30, unmountOnClose = $$new_props.unmountOnClose);
		if ("returnFocusAfterClose" in $$props) $$invalidate(31, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
		if ("transitionType" in $$props) $$invalidate(9, transitionType = $$new_props.transitionType);
		if ("transitionOptions" in $$props) $$invalidate(10, transitionOptions = $$new_props.transitionOptions);
		if ("hasOpened" in $$props) hasOpened = $$new_props.hasOpened;
		if ("_isMounted" in $$props) $$invalidate(11, _isMounted = $$new_props._isMounted);
		if ("_triggeringElement" in $$props) _triggeringElement = $$new_props._triggeringElement;
		if ("_originalBodyPadding" in $$props) _originalBodyPadding = $$new_props._originalBodyPadding;
		if ("_lastIsOpen" in $$props) _lastIsOpen = $$new_props._lastIsOpen;
		if ("_lastHasOpened" in $$props) _lastHasOpened = $$new_props._lastHasOpened;
		if ("_dialog" in $$props) $$invalidate(12, _dialog = $$new_props._dialog);
		if ("_mouseDownElement" in $$props) _mouseDownElement = $$new_props._mouseDownElement;
		if ("_removeEscListener" in $$props) _removeEscListener = $$new_props._removeEscListener;
		if ("classes" in $$props) $$invalidate(13, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*className, size, centered, scrollable*/ 15204352) {
			$: $$invalidate(13, classes = classnames(dialogBaseClass, className, {
				[`modal-${size}`]: size,
				[`${dialogBaseClass}-centered`]: centered,
				[`${dialogBaseClass}-scrollable`]: scrollable
			}));
		}
	};

	return [
		staticModal,
		isOpen,
		labelledBy,
		backdrop,
		wrapClassName,
		modalClassName,
		backdropClassName,
		contentClassName,
		backdropDuration,
		transitionType,
		transitionOptions,
		_isMounted,
		_dialog,
		classes,
		handleBackdropClick,
		onModalOpened,
		onModalClosed,
		handleBackdropMouseDown,
		$$restProps,
		className,
		autoFocus,
		centered,
		scrollable,
		size,
		toggle,
		onEnter,
		onExit,
		onOpened,
		onClosed,
		fade$1,
		unmountOnClose,
		returnFocusAfterClose,
		$$scope,
		slots,
		div1_binding
	];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$O,
			create_fragment$O,
			safe_not_equal,
			{
				class: 19,
				static: 0,
				isOpen: 1,
				autoFocus: 20,
				centered: 21,
				scrollable: 22,
				size: 23,
				toggle: 24,
				labelledBy: 2,
				backdrop: 3,
				onEnter: 25,
				onExit: 26,
				onOpened: 27,
				onClosed: 28,
				wrapClassName: 4,
				modalClassName: 5,
				backdropClassName: 6,
				contentClassName: 7,
				fade: 29,
				backdropDuration: 8,
				unmountOnClose: 30,
				returnFocusAfterClose: 31,
				transitionType: 9,
				transitionOptions: 10
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$O.name
		});
	}

	get class() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get static() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set static(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoFocus() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoFocus(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get centered() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set centered(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollable() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollable(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelledBy() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelledBy(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEnter() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEnter(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExit() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExit(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onOpened() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onOpened(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onClosed() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onClosed(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrapClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrapClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get modalClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set modalClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contentClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contentClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fade() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fade(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropDuration() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropDuration(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get unmountOnClose() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set unmountOnClose(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get returnFocusAfterClose() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set returnFocusAfterClose(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionType() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionType(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionOptions() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionOptions(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ModalBody.svelte generated by Svelte v3.37.0 */
const file$P = "node_modules/sveltestrap/src/ModalBody.svelte";

function create_fragment$P(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$P, 9, 0, 165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$P($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ModalBody", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "modal-body"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class ModalBody extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$P, create_fragment$P, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModalBody",
			options,
			id: create_fragment$P.name
		});
	}

	get class() {
		throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ModalFooter.svelte generated by Svelte v3.37.0 */
const file$Q = "node_modules/sveltestrap/src/ModalFooter.svelte";

function create_fragment$Q(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$Q, 9, 0, 167);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Q($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ModalFooter", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "modal-footer"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class ModalFooter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModalFooter",
			options,
			id: create_fragment$Q.name
		});
	}

	get class() {
		throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ModalHeader.svelte generated by Svelte v3.37.0 */
const file$R = "node_modules/sveltestrap/src/ModalHeader.svelte";
const get_close_slot_changes = dirty => ({});
const get_close_slot_context = ctx => ({});

// (21:4) {:else}
function create_else_block$f(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$f.name,
		type: "else",
		source: "(21:4) {:else}",
		ctx
	});

	return block;
}

// (19:4) {#if children}
function create_if_block_1$a(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 4) set_data_dev(t, /*children*/ ctx[2]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(19:4) {#if children}",
		ctx
	});

	return block;
}

// (26:4) {#if typeof toggle === 'function'}
function create_if_block$i(ctx) {
	let button;
	let span;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			t = text(/*closeIcon*/ ctx[3]);
			attr_dev(span, "aria-hidden", "true");
			add_location(span, file$R, 31, 8, 735);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "close");
			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			add_location(button, file$R, 26, 6, 612);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*toggle*/ ctx[0])) /*toggle*/ ctx[0].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*closeIcon*/ 8) set_data_dev(t, /*closeIcon*/ ctx[3]);

			if (dirty & /*closeAriaLabel*/ 2) {
				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$i.name,
		type: "if",
		source: "(26:4) {#if typeof toggle === 'function'}",
		ctx
	});

	return block;
}

// (25:21)      
function fallback_block$2(ctx) {
	let if_block_anchor;
	let if_block = typeof /*toggle*/ ctx[0] === "function" && create_if_block$i(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (typeof /*toggle*/ ctx[0] === "function") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$i(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$2.name,
		type: "fallback",
		source: "(25:21)      ",
		ctx
	});

	return block;
}

function create_fragment$R(ctx) {
	let div;
	let h5;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$a, create_else_block$f];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const close_slot_template = /*#slots*/ ctx[9].close;
	const close_slot = create_slot(close_slot_template, ctx, /*$$scope*/ ctx[8], get_close_slot_context);
	const close_slot_or_fallback = close_slot || fallback_block$2(ctx);
	let div_levels = [/*$$restProps*/ ctx[5], { class: /*classes*/ ctx[4] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			h5 = element("h5");
			if_block.c();
			t = space();
			if (close_slot_or_fallback) close_slot_or_fallback.c();
			attr_dev(h5, "class", "modal-title");
			add_location(h5, file$R, 17, 2, 439);
			set_attributes(div, div_data);
			add_location(div, file$R, 16, 0, 398);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h5);
			if_blocks[current_block_type_index].m(h5, null);
			append_dev(div, t);

			if (close_slot_or_fallback) {
				close_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(h5, null);
			}

			if (close_slot) {
				if (close_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(close_slot, close_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_close_slot_changes, get_close_slot_context);
				}
			} else {
				if (close_slot_or_fallback && close_slot_or_fallback.p && dirty & /*closeAriaLabel, toggle, closeIcon*/ 11) {
					close_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(close_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(close_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$R($$self, $$props, $$invalidate) {
	let closeIcon;
	let classes;
	const omit_props_names = ["class","toggle","closeAriaLabel","charCode","children"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ModalHeader", slots, ['default','close']);
	let { class: className = "" } = $$props;
	let { toggle = undefined } = $$props;
	let { closeAriaLabel = "Close" } = $$props;
	let { charCode = 215 } = $$props;
	let { children = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("toggle" in $$new_props) $$invalidate(0, toggle = $$new_props.toggle);
		if ("closeAriaLabel" in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ("charCode" in $$new_props) $$invalidate(7, charCode = $$new_props.charCode);
		if ("children" in $$new_props) $$invalidate(2, children = $$new_props.children);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		toggle,
		closeAriaLabel,
		charCode,
		children,
		closeIcon,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("toggle" in $$props) $$invalidate(0, toggle = $$new_props.toggle);
		if ("closeAriaLabel" in $$props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ("charCode" in $$props) $$invalidate(7, charCode = $$new_props.charCode);
		if ("children" in $$props) $$invalidate(2, children = $$new_props.children);
		if ("closeIcon" in $$props) $$invalidate(3, closeIcon = $$new_props.closeIcon);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*charCode*/ 128) {
			$: $$invalidate(3, closeIcon = typeof charCode === "number"
			? String.fromCharCode(charCode)
			: charCode);
		}

		if ($$self.$$.dirty & /*className*/ 64) {
			$: $$invalidate(4, classes = classnames(className, "modal-header"));
		}
	};

	return [
		toggle,
		closeAriaLabel,
		children,
		closeIcon,
		classes,
		$$restProps,
		className,
		charCode,
		$$scope,
		slots
	];
}

class ModalHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$R, create_fragment$R, safe_not_equal, {
			class: 6,
			toggle: 0,
			closeAriaLabel: 1,
			charCode: 7,
			children: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModalHeader",
			options,
			id: create_fragment$R.name
		});
	}

	get class() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeAriaLabel() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeAriaLabel(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get charCode() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set charCode(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Nav.svelte generated by Svelte v3.37.0 */
const file$S = "node_modules/sveltestrap/src/Nav.svelte";

function create_fragment$S(ctx) {
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let ul_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = assign(ul_data, ul_levels[i]);
	}

	const block = {
		c: function create() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			set_attributes(ul, ul_data);
			add_location(ul, file$S, 39, 0, 941);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getVerticalClass(vertical) {
	if (vertical === false) {
		return false;
	} else if (vertical === true || vertical === "xs") {
		return "flex-column";
	}

	return `flex-${vertical}-column`;
}

function instance$S($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","tabs","pills","vertical","horizontal","justified","fill","navbar","card"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Nav", slots, ['default']);
	let { class: className = "" } = $$props;
	let { tabs = false } = $$props;
	let { pills = false } = $$props;
	let { vertical = false } = $$props;
	let { horizontal = "" } = $$props;
	let { justified = false } = $$props;
	let { fill = false } = $$props;
	let { navbar = false } = $$props;
	let { card = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("tabs" in $$new_props) $$invalidate(3, tabs = $$new_props.tabs);
		if ("pills" in $$new_props) $$invalidate(4, pills = $$new_props.pills);
		if ("vertical" in $$new_props) $$invalidate(5, vertical = $$new_props.vertical);
		if ("horizontal" in $$new_props) $$invalidate(6, horizontal = $$new_props.horizontal);
		if ("justified" in $$new_props) $$invalidate(7, justified = $$new_props.justified);
		if ("fill" in $$new_props) $$invalidate(8, fill = $$new_props.fill);
		if ("navbar" in $$new_props) $$invalidate(9, navbar = $$new_props.navbar);
		if ("card" in $$new_props) $$invalidate(10, card = $$new_props.card);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		tabs,
		pills,
		vertical,
		horizontal,
		justified,
		fill,
		navbar,
		card,
		getVerticalClass,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("tabs" in $$props) $$invalidate(3, tabs = $$new_props.tabs);
		if ("pills" in $$props) $$invalidate(4, pills = $$new_props.pills);
		if ("vertical" in $$props) $$invalidate(5, vertical = $$new_props.vertical);
		if ("horizontal" in $$props) $$invalidate(6, horizontal = $$new_props.horizontal);
		if ("justified" in $$props) $$invalidate(7, justified = $$new_props.justified);
		if ("fill" in $$props) $$invalidate(8, fill = $$new_props.fill);
		if ("navbar" in $$props) $$invalidate(9, navbar = $$new_props.navbar);
		if ("card" in $$props) $$invalidate(10, card = $$new_props.card);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill*/ 2044) {
			$: $$invalidate(0, classes = classnames(className, navbar ? "navbar-nav" : "nav", horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
				"nav-tabs": tabs,
				"card-header-tabs": card && tabs,
				"nav-pills": pills,
				"card-header-pills": card && pills,
				"nav-justified": justified,
				"nav-fill": fill
			}));
		}
	};

	return [
		classes,
		$$restProps,
		className,
		tabs,
		pills,
		vertical,
		horizontal,
		justified,
		fill,
		navbar,
		card,
		$$scope,
		slots
	];
}

class Nav extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$S, create_fragment$S, safe_not_equal, {
			class: 2,
			tabs: 3,
			pills: 4,
			vertical: 5,
			horizontal: 6,
			justified: 7,
			fill: 8,
			navbar: 9,
			card: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav",
			options,
			id: create_fragment$S.name
		});
	}

	get class() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabs() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pills() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pills(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get horizontal() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set horizontal(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get justified() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set justified(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbar() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbar(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get card() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set card(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Navbar.svelte generated by Svelte v3.37.0 */
const file$T = "node_modules/sveltestrap/src/Navbar.svelte";

function create_fragment$T(ctx) {
	let nav;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let nav_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let nav_data = {};

	for (let i = 0; i < nav_levels.length; i += 1) {
		nav_data = assign(nav_data, nav_levels[i]);
	}

	const block = {
		c: function create() {
			nav = element("nav");
			if (default_slot) default_slot.c();
			set_attributes(nav, nav_data);
			add_location(nav, file$T, 31, 0, 719);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);

			if (default_slot) {
				default_slot.m(nav, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getExpandClass(expand) {
	if (expand === false) {
		return false;
	} else if (expand === true || expand === "xs") {
		return "navbar-expand";
	}

	return `navbar-expand-${expand}`;
}

function instance$T($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","light","dark","fixed","sticky","color","expand"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Navbar", slots, ['default']);
	let { class: className = "" } = $$props;
	let { light = false } = $$props;
	let { dark = false } = $$props;
	let { fixed = "" } = $$props;
	let { sticky = "" } = $$props;
	let { color = "" } = $$props;
	let { expand = false || "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("light" in $$new_props) $$invalidate(3, light = $$new_props.light);
		if ("dark" in $$new_props) $$invalidate(4, dark = $$new_props.dark);
		if ("fixed" in $$new_props) $$invalidate(5, fixed = $$new_props.fixed);
		if ("sticky" in $$new_props) $$invalidate(6, sticky = $$new_props.sticky);
		if ("color" in $$new_props) $$invalidate(7, color = $$new_props.color);
		if ("expand" in $$new_props) $$invalidate(8, expand = $$new_props.expand);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		light,
		dark,
		fixed,
		sticky,
		color,
		expand,
		getExpandClass,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("light" in $$props) $$invalidate(3, light = $$new_props.light);
		if ("dark" in $$props) $$invalidate(4, dark = $$new_props.dark);
		if ("fixed" in $$props) $$invalidate(5, fixed = $$new_props.fixed);
		if ("sticky" in $$props) $$invalidate(6, sticky = $$new_props.sticky);
		if ("color" in $$props) $$invalidate(7, color = $$new_props.color);
		if ("expand" in $$props) $$invalidate(8, expand = $$new_props.expand);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, expand, light, dark, color, fixed, sticky*/ 508) {
			$: $$invalidate(0, classes = classnames(className, "navbar", getExpandClass(expand), {
				"navbar-light": light,
				"navbar-dark": dark,
				[`bg-${color}`]: color,
				[`fixed-${fixed}`]: fixed,
				[`sticky-${sticky}`]: sticky
			}));
		}
	};

	return [
		classes,
		$$restProps,
		className,
		light,
		dark,
		fixed,
		sticky,
		color,
		expand,
		$$scope,
		slots
	];
}

class Navbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$T, create_fragment$T, safe_not_equal, {
			class: 2,
			light: 3,
			dark: 4,
			fixed: 5,
			sticky: 6,
			color: 7,
			expand: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navbar",
			options,
			id: create_fragment$T.name
		});
	}

	get class() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get light() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set light(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixed() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixed(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sticky() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sticky(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expand() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expand(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/NavItem.svelte generated by Svelte v3.37.0 */
const file$U = "node_modules/sveltestrap/src/NavItem.svelte";

function create_fragment$U(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$U, 10, 0, 219);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$U($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NavItem", slots, ['default']);
	let { class: className = "" } = $$props;
	let { active = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(3, active = $$new_props.active);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, active, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(3, active = $$new_props.active);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active*/ 12) {
			$: $$invalidate(0, classes = classnames(className, "nav-item", active ? "active" : false));
		}
	};

	return [classes, $$restProps, className, active, $$scope, slots];
}

class NavItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$U, create_fragment$U, safe_not_equal, { class: 2, active: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavItem",
			options,
			id: create_fragment$U.name
		});
	}

	get class() {
		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/NavLink.svelte generated by Svelte v3.37.0 */
const file$V = "node_modules/sveltestrap/src/NavLink.svelte";

function create_fragment$V(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let a_levels = [
		/*$$restProps*/ ctx[3],
		{ href: /*href*/ ctx[0] },
		{ class: /*classes*/ ctx[1] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$V, 27, 0, 472);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a, "click", /*click_handler*/ ctx[9], false, false, false),
					listen_dev(a, "click", /*handleClick*/ ctx[2], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$V($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","disabled","active","href"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NavLink", slots, ['default']);
	let { class: className = "" } = $$props;
	let { disabled = false } = $$props;
	let { active = false } = $$props;
	let { href = "#" } = $$props;

	function handleClick(e) {
		if (disabled) {
			e.preventDefault();
			e.stopImmediatePropagation();
			return;
		}

		if (href === "#") {
			e.preventDefault();
		}
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("active" in $$new_props) $$invalidate(6, active = $$new_props.active);
		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		disabled,
		active,
		href,
		handleClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("active" in $$props) $$invalidate(6, active = $$new_props.active);
		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, disabled, active*/ 112) {
			$: $$invalidate(1, classes = classnames(className, "nav-link", { disabled, active }));
		}
	};

	return [
		href,
		classes,
		handleClick,
		$$restProps,
		className,
		disabled,
		active,
		$$scope,
		slots,
		click_handler
	];
}

class NavLink extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$V, create_fragment$V, safe_not_equal, {
			class: 4,
			disabled: 5,
			active: 6,
			href: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavLink",
			options,
			id: create_fragment$V.name
		});
	}

	get class() {
		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/NavbarBrand.svelte generated by Svelte v3.37.0 */
const file$W = "node_modules/sveltestrap/src/NavbarBrand.svelte";

function create_fragment$W(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let a_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ href: /*href*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$W, 10, 0, 192);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*click_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$W($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","href"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NavbarBrand", slots, ['default']);
	let { class: className = "" } = $$props;
	let { href = "/" } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, href, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$: $$invalidate(1, classes = classnames(className, "navbar-brand"));
		}
	};

	return [href, classes, $$restProps, className, $$scope, slots, click_handler];
}

class NavbarBrand extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$W, create_fragment$W, safe_not_equal, { class: 3, href: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavbarBrand",
			options,
			id: create_fragment$W.name
		});
	}

	get class() {
		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/NavbarToggler.svelte generated by Svelte v3.37.0 */
const file$X = "node_modules/sveltestrap/src/NavbarToggler.svelte";

// (13:8)      
function fallback_block$3(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "navbar-toggler-icon");
			add_location(span, file$X, 13, 4, 274);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$3.name,
		type: "fallback",
		source: "(13:8)      ",
		ctx
	});

	return block;
}

// (12:0) <Button {...$$restProps} on:click class={classes}>
function create_default_slot$3(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);

	const block = {
		c: function create() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m: function mount(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(12:0) <Button {...$$restProps} on:click class={classes}>",
		ctx
	});

	return block;
}

function create_fragment$X(ctx) {
	let button;
	let current;
	const button_spread_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];

	let button_props = {
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	for (let i = 0; i < button_spread_levels.length; i += 1) {
		button_props = assign(button_props, button_spread_levels[i]);
	}

	button = new Button({ props: button_props, $$inline: true });
	button.$on("click", /*click_handler*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = (dirty & /*$$restProps, classes*/ 3)
			? get_spread_update(button_spread_levels, [
					dirty & /*$$restProps*/ 2 && get_spread_object(/*$$restProps*/ ctx[1]),
					dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] }
				])
			: {};

			if (dirty & /*$$scope*/ 32) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$X($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NavbarToggler", slots, ['default']);
	let { class: className = "" } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, Button, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "navbar-toggler"));
		}
	};

	return [classes, $$restProps, className, slots, click_handler, $$scope];
}

class NavbarToggler extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$X, create_fragment$X, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavbarToggler",
			options,
			id: create_fragment$X.name
		});
	}

	get class() {
		throw new Error("<NavbarToggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<NavbarToggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Pagination.svelte generated by Svelte v3.37.0 */
const file$Y = "node_modules/sveltestrap/src/Pagination.svelte";

function create_fragment$Y(ctx) {
	let nav;
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let nav_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[1] },
		{ "aria-label": /*ariaLabel*/ ctx[0] }
	];

	let nav_data = {};

	for (let i = 0; i < nav_levels.length; i += 1) {
		nav_data = assign(nav_data, nav_levels[i]);
	}

	const block = {
		c: function create() {
			nav = element("nav");
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr_dev(ul, "class", /*listClasses*/ ctx[2]);
			add_location(ul, file$Y, 17, 2, 414);
			set_attributes(nav, nav_data);
			add_location(nav, file$Y, 16, 0, 350);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			if (!current || dirty & /*listClasses*/ 4) {
				attr_dev(ul, "class", /*listClasses*/ ctx[2]);
			}

			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Y($$self, $$props, $$invalidate) {
	let classes;
	let listClasses;
	const omit_props_names = ["class","listClassName","size","ariaLabel"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pagination", slots, ['default']);
	let { class: className = "" } = $$props;
	let { listClassName = "" } = $$props;
	let { size = "" } = $$props;
	let { ariaLabel = "pagination" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("listClassName" in $$new_props) $$invalidate(5, listClassName = $$new_props.listClassName);
		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
		if ("ariaLabel" in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		listClassName,
		size,
		ariaLabel,
		classes,
		listClasses
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("listClassName" in $$props) $$invalidate(5, listClassName = $$new_props.listClassName);
		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
		if ("ariaLabel" in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("listClasses" in $$props) $$invalidate(2, listClasses = $$new_props.listClasses);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$: $$invalidate(1, classes = classnames(className));
		}

		if ($$self.$$.dirty & /*listClassName, size*/ 96) {
			$: $$invalidate(2, listClasses = classnames(listClassName, "pagination", { [`pagination-${size}`]: !!size }));
		}
	};

	return [
		ariaLabel,
		classes,
		listClasses,
		$$restProps,
		className,
		listClassName,
		size,
		$$scope,
		slots
	];
}

class Pagination extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
			class: 4,
			listClassName: 5,
			size: 6,
			ariaLabel: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pagination",
			options,
			id: create_fragment$Y.name
		});
	}

	get class() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listClassName() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listClassName(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/PaginationItem.svelte generated by Svelte v3.37.0 */
const file$Z = "node_modules/sveltestrap/src/PaginationItem.svelte";

function create_fragment$Z(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$Z, 14, 0, 256);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Z($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PaginationItem", slots, ['default']);
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(3, active = $$new_props.active);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		active,
		disabled,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(3, active = $$new_props.active);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active, disabled*/ 28) {
			$: $$invalidate(0, classes = classnames(className, "page-item", { active, disabled }));
		}
	};

	return [classes, $$restProps, className, active, disabled, $$scope, slots];
}

class PaginationItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { class: 2, active: 3, disabled: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PaginationItem",
			options,
			id: create_fragment$Z.name
		});
	}

	get class() {
		throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/PaginationLink.svelte generated by Svelte v3.37.0 */
const file$_ = "node_modules/sveltestrap/src/PaginationLink.svelte";

// (47:2) {:else}
function create_else_block$g(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$g.name,
		type: "else",
		source: "(47:2) {:else}",
		ctx
	});

	return block;
}

// (42:2) {#if previous || next || first || last}
function create_if_block$j(ctx) {
	let span0;
	let t0;
	let span1;
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	const default_slot_or_fallback = default_slot || fallback_block$4(ctx);

	const block = {
		c: function create() {
			span0 = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t0 = space();
			span1 = element("span");
			t1 = text(/*realLabel*/ ctx[7]);
			attr_dev(span0, "aria-hidden", "true");
			add_location(span0, file$_, 42, 4, 948);
			attr_dev(span1, "class", "sr-only");
			add_location(span1, file$_, 45, 4, 1024);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span0, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span0, null);
			}

			insert_dev(target, t0, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*defaultCaret*/ 32) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*realLabel*/ 128) set_data_dev(t1, /*realLabel*/ ctx[7]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$j.name,
		type: "if",
		source: "(42:2) {#if previous || next || first || last}",
		ctx
	});

	return block;
}

// (44:12) {defaultCaret}
function fallback_block$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*defaultCaret*/ ctx[5]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*defaultCaret*/ 32) set_data_dev(t, /*defaultCaret*/ ctx[5]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$4.name,
		type: "fallback",
		source: "(44:12) {defaultCaret}",
		ctx
	});

	return block;
}

function create_fragment$_(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$j, create_else_block$g];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*previous*/ ctx[1] || /*next*/ ctx[0] || /*first*/ ctx[2] || /*last*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		/*$$restProps*/ ctx[8],
		{ class: /*classes*/ ctx[6] },
		{ href: /*href*/ ctx[4] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if_block.c();
			set_attributes(a, a_data);
			add_location(a, file$_, 40, 0, 849);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*click_handler*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(a, null);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				(!current || dirty & /*href*/ 16) && { href: /*href*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$_($$self, $$props, $$invalidate) {
	let classes;
	let realLabel;
	const omit_props_names = ["class","next","previous","first","last","ariaLabel","href"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PaginationLink", slots, ['default']);
	let { class: className = "" } = $$props;
	let { next = false } = $$props;
	let { previous = false } = $$props;
	let { first = false } = $$props;
	let { last = false } = $$props;
	let { ariaLabel = "" } = $$props;
	let { href = "" } = $$props;
	let defaultAriaLabel;
	let defaultCaret;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ("next" in $$new_props) $$invalidate(0, next = $$new_props.next);
		if ("previous" in $$new_props) $$invalidate(1, previous = $$new_props.previous);
		if ("first" in $$new_props) $$invalidate(2, first = $$new_props.first);
		if ("last" in $$new_props) $$invalidate(3, last = $$new_props.last);
		if ("ariaLabel" in $$new_props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
		if ("href" in $$new_props) $$invalidate(4, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		next,
		previous,
		first,
		last,
		ariaLabel,
		href,
		defaultAriaLabel,
		defaultCaret,
		classes,
		realLabel
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
		if ("next" in $$props) $$invalidate(0, next = $$new_props.next);
		if ("previous" in $$props) $$invalidate(1, previous = $$new_props.previous);
		if ("first" in $$props) $$invalidate(2, first = $$new_props.first);
		if ("last" in $$props) $$invalidate(3, last = $$new_props.last);
		if ("ariaLabel" in $$props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
		if ("href" in $$props) $$invalidate(4, href = $$new_props.href);
		if ("defaultAriaLabel" in $$props) $$invalidate(11, defaultAriaLabel = $$new_props.defaultAriaLabel);
		if ("defaultCaret" in $$props) $$invalidate(5, defaultCaret = $$new_props.defaultCaret);
		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
		if ("realLabel" in $$props) $$invalidate(7, realLabel = $$new_props.realLabel);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 512) {
			$: $$invalidate(6, classes = classnames(className, "page-link"));
		}

		if ($$self.$$.dirty & /*previous, next, first, last*/ 15) {
			$: if (previous) {
				$$invalidate(11, defaultAriaLabel = "Previous");
			} else if (next) {
				$$invalidate(11, defaultAriaLabel = "Next");
			} else if (first) {
				$$invalidate(11, defaultAriaLabel = "First");
			} else if (last) {
				$$invalidate(11, defaultAriaLabel = "Last");
			}
		}

		if ($$self.$$.dirty & /*ariaLabel, defaultAriaLabel*/ 3072) {
			$: $$invalidate(7, realLabel = ariaLabel || defaultAriaLabel);
		}

		if ($$self.$$.dirty & /*previous, next, first, last*/ 15) {
			$: if (previous) {
				$$invalidate(5, defaultCaret = "â€¹");
			} else if (next) {
				$$invalidate(5, defaultCaret = "â€º");
			} else if (first) {
				$$invalidate(5, defaultCaret = "Â«");
			} else if (last) {
				$$invalidate(5, defaultCaret = "Â»");
			}
		}
	};

	return [
		next,
		previous,
		first,
		last,
		href,
		defaultCaret,
		classes,
		realLabel,
		$$restProps,
		className,
		ariaLabel,
		defaultAriaLabel,
		$$scope,
		slots,
		click_handler
	];
}

class PaginationLink extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$_, create_fragment$_, safe_not_equal, {
			class: 9,
			next: 0,
			previous: 1,
			first: 2,
			last: 3,
			ariaLabel: 10,
			href: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PaginationLink",
			options,
			id: create_fragment$_.name
		});
	}

	get class() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get next() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set next(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get previous() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set previous(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get first() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set first(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get last() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set last(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if ("development" !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if ("development" !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets;

  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top) {
      sideY = bottom; // $FlowFixMe[prop-missing]

      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right; // $FlowFixMe[prop-missing]

      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref4) {
  var state = _ref4.state,
      options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if ("development" !== "production") {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect$2(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};

var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

var hash$1 = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if ("development" !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases â€“ research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

    if (checkMainAxis) {
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if ("development" !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if ("development" !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if ("development" !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if ("development" !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper$2 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

/* node_modules/sveltestrap/src/Popover.svelte generated by Svelte v3.37.0 */

const { Error: Error_1$3 } = globals;
const file$$ = "node_modules/sveltestrap/src/Popover.svelte";
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});

// (103:0) {#if isOpen}
function create_if_block$k(ctx) {
	let div2;
	let div0;
	let t0;
	let h3;
	let t1;
	let div1;
	let current_block_type_index;
	let if_block;
	let current;
	const title_slot_template = /*#slots*/ ctx[16].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[15], get_title_slot_context);
	const title_slot_or_fallback = title_slot || fallback_block$5(ctx);
	const if_block_creators = [create_if_block_1$b, create_else_block$h];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div2_levels = [
		/*$$restProps*/ ctx[6],
		{ class: /*classes*/ ctx[5] },
		{ role: "tooltip" },
		{
			"x-placement": /*popperPlacement*/ ctx[4]
		}
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			h3 = element("h3");
			if (title_slot_or_fallback) title_slot_or_fallback.c();
			t1 = space();
			div1 = element("div");
			if_block.c();
			attr_dev(div0, "class", "arrow");
			attr_dev(div0, "data-popper-arrow", "");
			add_location(div0, file$$, 109, 4, 2723);
			attr_dev(h3, "class", "popover-header");
			add_location(h3, file$$, 110, 4, 2767);
			attr_dev(div1, "class", "popover-body");
			add_location(div1, file$$, 113, 4, 2849);
			set_attributes(div2, div2_data);
			add_location(div2, file$$, 103, 2, 2593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t0);
			append_dev(div2, h3);

			if (title_slot_or_fallback) {
				title_slot_or_fallback.m(h3, null);
			}

			append_dev(div2, t1);
			append_dev(div2, div1);
			if_blocks[current_block_type_index].m(div1, null);
			/*div2_binding*/ ctx[17](div2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (title_slot) {
				if (title_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_title_slot_changes, get_title_slot_context);
				}
			} else {
				if (title_slot_or_fallback && title_slot_or_fallback.p && dirty & /*title*/ 4) {
					title_slot_or_fallback.p(ctx, dirty);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div1, null);
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				{ role: "tooltip" },
				(!current || dirty & /*popperPlacement*/ 16) && {
					"x-placement": /*popperPlacement*/ ctx[4]
				}
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot_or_fallback, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot_or_fallback, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
			if_blocks[current_block_type_index].d();
			/*div2_binding*/ ctx[17](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$k.name,
		type: "if",
		source: "(103:0) {#if isOpen}",
		ctx
	});

	return block;
}

// (112:25) {title}
function fallback_block$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*title*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$5.name,
		type: "fallback",
		source: "(112:25) {title}",
		ctx
	});

	return block;
}

// (117:6) {:else}
function create_else_block$h(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$h.name,
		type: "else",
		source: "(117:6) {:else}",
		ctx
	});

	return block;
}

// (115:6) {#if children}
function create_if_block_1$b(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$b.name,
		type: "if",
		source: "(115:6) {#if children}",
		ctx
	});

	return block;
}

function create_fragment$$(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$k(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error_1$3("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$k(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$$($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","animation","children","dismissible","isOpen","placement","target","title","trigger"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Popover", slots, ['title','default']);
	let { class: className = "" } = $$props;
	let { animation = true } = $$props;
	let { children = undefined } = $$props;
	let { dismissible = false } = $$props;
	let { isOpen = false } = $$props;
	let { placement = "top" } = $$props;
	let { target = "" } = $$props;
	let { title = "" } = $$props;
	let { trigger = "click" } = $$props;
	let targetEl;
	let popoverEl;
	let popperInstance;
	let popperPlacement = placement;

	const checkPopperPlacement = {
		name: "checkPopperPlacement",
		enabled: true,
		phase: "main",
		fn({ state }) {
			$$invalidate(4, popperPlacement = state.placement);
		}
	};

	const open = () => $$invalidate(0, isOpen = true);
	const close = () => $$invalidate(0, isOpen = false);
	const toggle = () => $$invalidate(0, isOpen = !isOpen);

	onMount(() => {
		$$invalidate(13, targetEl = document.querySelector(`#${target}`));

		switch (trigger) {
			case "hover":
				targetEl.addEventListener("mouseover", open);
				targetEl.addEventListener("mouseleave", close);
				break;
			case "focus":
				targetEl.addEventListener("focus", open);
				targetEl.addEventListener("blur", close);
				break;
			default:
				targetEl.addEventListener("click", toggle);
				if (dismissible) targetEl.addEventListener("blur", close);
				break;
		}

		return () => {
			switch (trigger) {
				case "hover":
					targetEl.removeEventListener("mouseover", open);
					targetEl.removeEventListener("mouseleave", close);
					break;
				case "focus":
					targetEl.removeEventListener("focus", open);
					targetEl.removeEventListener("blur", close);
					break;
				default:
					targetEl.removeEventListener("click", toggle);
					if (dismissible) targetEl.removeEventListener("blur", close);
					break;
			}
		};
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			popoverEl = $$value;
			$$invalidate(3, popoverEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("animation" in $$new_props) $$invalidate(8, animation = $$new_props.animation);
		if ("children" in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ("dismissible" in $$new_props) $$invalidate(9, dismissible = $$new_props.dismissible);
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("placement" in $$new_props) $$invalidate(10, placement = $$new_props.placement);
		if ("target" in $$new_props) $$invalidate(11, target = $$new_props.target);
		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
		if ("trigger" in $$new_props) $$invalidate(12, trigger = $$new_props.trigger);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		createPopper: createPopper$2,
		classnames,
		className,
		animation,
		children,
		dismissible,
		isOpen,
		placement,
		target,
		title,
		trigger,
		targetEl,
		popoverEl,
		popperInstance,
		popperPlacement,
		checkPopperPlacement,
		open,
		close,
		toggle,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("animation" in $$props) $$invalidate(8, animation = $$new_props.animation);
		if ("children" in $$props) $$invalidate(1, children = $$new_props.children);
		if ("dismissible" in $$props) $$invalidate(9, dismissible = $$new_props.dismissible);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("placement" in $$props) $$invalidate(10, placement = $$new_props.placement);
		if ("target" in $$props) $$invalidate(11, target = $$new_props.target);
		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
		if ("trigger" in $$props) $$invalidate(12, trigger = $$new_props.trigger);
		if ("targetEl" in $$props) $$invalidate(13, targetEl = $$new_props.targetEl);
		if ("popoverEl" in $$props) $$invalidate(3, popoverEl = $$new_props.popoverEl);
		if ("popperInstance" in $$props) $$invalidate(14, popperInstance = $$new_props.popperInstance);
		if ("popperPlacement" in $$props) $$invalidate(4, popperPlacement = $$new_props.popperPlacement);
		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen, popoverEl, targetEl, placement, popperInstance*/ 25609) {
			$: {
				if (isOpen && popoverEl) {
					$$invalidate(14, popperInstance = createPopper$2(targetEl, popoverEl, {
						placement,
						modifiers: [
							checkPopperPlacement,
							{
								name: "offset",
								options: {
									offset: () => {
										return [0, 8];
									}
								}
							}
						]
					}));
				} else if (popperInstance) {
					popperInstance.destroy();
					$$invalidate(14, popperInstance = undefined);
				}
			}
		}

		if ($$self.$$.dirty & /*target*/ 2048) {
			$: if (!target) {
				throw new Error("Need target!");
			}
		}

		if ($$self.$$.dirty & /*className, animation, popperPlacement, isOpen*/ 401) {
			$: $$invalidate(5, classes = classnames(className, "popover", animation ? "fade" : false, `bs-popover-${popperPlacement}`, isOpen ? "show" : false));
		}
	};

	return [
		isOpen,
		children,
		title,
		popoverEl,
		popperPlacement,
		classes,
		$$restProps,
		className,
		animation,
		dismissible,
		placement,
		target,
		trigger,
		targetEl,
		popperInstance,
		$$scope,
		slots,
		div2_binding
	];
}

class Popover extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
			class: 7,
			animation: 8,
			children: 1,
			dismissible: 9,
			isOpen: 0,
			placement: 10,
			target: 11,
			title: 2,
			trigger: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Popover",
			options,
			id: create_fragment$$.name
		});
	}

	get class() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animation() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animation(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dismissible() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dismissible(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placement() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placement(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trigger() {
		throw new Error_1$3("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trigger(value) {
		throw new Error_1$3("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Progress.svelte generated by Svelte v3.37.0 */
const file$10 = "node_modules/sveltestrap/src/Progress.svelte";

// (43:0) {:else}
function create_else_block_1$2(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_2$8, create_else_block_2$2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*multi*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let div_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[4] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$10, 43, 2, 993);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(43:0) {:else}",
		ctx
	});

	return block;
}

// (28:0) {#if bar}
function create_if_block$l(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$c, create_else_block$i];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*multi*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$l.name,
		type: "if",
		source: "(28:0) {#if bar}",
		ctx
	});

	return block;
}

// (47:4) {:else}
function create_else_block_2$2(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", /*progressBarClasses*/ ctx[5]);
			set_style(div, "width", /*percent*/ ctx[6] + "%");
			attr_dev(div, "role", "progressbar");
			attr_dev(div, "aria-valuenow", /*value*/ ctx[2]);
			attr_dev(div, "aria-valuemin", "0");
			attr_dev(div, "aria-valuemax", /*max*/ ctx[3]);
			add_location(div, file$10, 47, 6, 1081);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			if (!current || dirty & /*progressBarClasses*/ 32) {
				attr_dev(div, "class", /*progressBarClasses*/ ctx[5]);
			}

			if (!current || dirty & /*percent*/ 64) {
				set_style(div, "width", /*percent*/ ctx[6] + "%");
			}

			if (!current || dirty & /*value*/ 4) {
				attr_dev(div, "aria-valuenow", /*value*/ ctx[2]);
			}

			if (!current || dirty & /*max*/ 8) {
				attr_dev(div, "aria-valuemax", /*max*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$2.name,
		type: "else",
		source: "(47:4) {:else}",
		ctx
	});

	return block;
}

// (45:4) {#if multi}
function create_if_block_2$8(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$8.name,
		type: "if",
		source: "(45:4) {#if multi}",
		ctx
	});

	return block;
}

// (31:2) {:else}
function create_else_block$i(ctx) {
	let div;
	let div_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let div_levels = [
		/*$$restProps*/ ctx[7],
		{ class: /*progressBarClasses*/ ctx[5] },
		{
			style: div_style_value = "width: " + /*percent*/ ctx[6] + "%"
		},
		{ role: "progressbar" },
		{ "aria-valuenow": /*value*/ ctx[2] },
		{ "aria-valuemin": "0" },
		{ "aria-valuemax": /*max*/ ctx[3] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$10, 31, 4, 752);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*progressBarClasses*/ 32) && { class: /*progressBarClasses*/ ctx[5] },
				(!current || dirty & /*percent*/ 64 && div_style_value !== (div_style_value = "width: " + /*percent*/ ctx[6] + "%")) && { style: div_style_value },
				{ role: "progressbar" },
				(!current || dirty & /*value*/ 4) && { "aria-valuenow": /*value*/ ctx[2] },
				{ "aria-valuemin": "0" },
				(!current || dirty & /*max*/ 8) && { "aria-valuemax": /*max*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$i.name,
		type: "else",
		source: "(31:2) {:else}",
		ctx
	});

	return block;
}

// (29:2) {#if multi}
function create_if_block_1$c(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$c.name,
		type: "if",
		source: "(29:2) {#if multi}",
		ctx
	});

	return block;
}

function create_fragment$10(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$l, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*bar*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$10.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$10($$self, $$props, $$invalidate) {
	let classes;
	let progressBarClasses;
	let percent;

	const omit_props_names = [
		"class","bar","multi","value","max","animated","striped","color","barClassName"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Progress", slots, ['default']);
	let { class: className = "" } = $$props;
	let { bar = false } = $$props;
	let { multi = false } = $$props;
	let { value = 0 } = $$props;
	let { max = 100 } = $$props;
	let { animated = false } = $$props;
	let { striped = false } = $$props;
	let { color = "" } = $$props;
	let { barClassName = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("bar" in $$new_props) $$invalidate(0, bar = $$new_props.bar);
		if ("multi" in $$new_props) $$invalidate(1, multi = $$new_props.multi);
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("max" in $$new_props) $$invalidate(3, max = $$new_props.max);
		if ("animated" in $$new_props) $$invalidate(9, animated = $$new_props.animated);
		if ("striped" in $$new_props) $$invalidate(10, striped = $$new_props.striped);
		if ("color" in $$new_props) $$invalidate(11, color = $$new_props.color);
		if ("barClassName" in $$new_props) $$invalidate(12, barClassName = $$new_props.barClassName);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		bar,
		multi,
		value,
		max,
		animated,
		striped,
		color,
		barClassName,
		classes,
		progressBarClasses,
		percent
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("bar" in $$props) $$invalidate(0, bar = $$new_props.bar);
		if ("multi" in $$props) $$invalidate(1, multi = $$new_props.multi);
		if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
		if ("max" in $$props) $$invalidate(3, max = $$new_props.max);
		if ("animated" in $$props) $$invalidate(9, animated = $$new_props.animated);
		if ("striped" in $$props) $$invalidate(10, striped = $$new_props.striped);
		if ("color" in $$props) $$invalidate(11, color = $$new_props.color);
		if ("barClassName" in $$props) $$invalidate(12, barClassName = $$new_props.barClassName);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
		if ("progressBarClasses" in $$props) $$invalidate(5, progressBarClasses = $$new_props.progressBarClasses);
		if ("percent" in $$props) $$invalidate(6, percent = $$new_props.percent);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 256) {
			$: $$invalidate(4, classes = classnames(className, "progress"));
		}

		if ($$self.$$.dirty & /*bar, className, barClassName, animated, color, striped*/ 7937) {
			$: $$invalidate(5, progressBarClasses = classnames("progress-bar", bar ? className || barClassName : barClassName, animated ? "progress-bar-animated" : null, color ? `bg-${color}` : null, striped || animated ? "progress-bar-striped" : null));
		}

		if ($$self.$$.dirty & /*value, max*/ 12) {
			$: $$invalidate(6, percent = parseInt(value, 10) / parseInt(max, 10) * 100);
		}
	};

	return [
		bar,
		multi,
		value,
		max,
		classes,
		progressBarClasses,
		percent,
		$$restProps,
		className,
		animated,
		striped,
		color,
		barClassName,
		$$scope,
		slots
	];
}

class Progress extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
			class: 8,
			bar: 0,
			multi: 1,
			value: 2,
			max: 3,
			animated: 9,
			striped: 10,
			color: 11,
			barClassName: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Progress",
			options,
			id: create_fragment$10.name
		});
	}

	get class() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bar() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bar(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multi() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multi(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animated() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animated(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get striped() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set striped(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get barClassName() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set barClassName(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Row.svelte generated by Svelte v3.37.0 */
const file$11 = "node_modules/sveltestrap/src/Row.svelte";

function create_fragment$11(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$11, 38, 0, 957);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$11.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getCols(cols) {
	const colsValue = parseInt(cols);

	if (!isNaN(colsValue)) {
		if (colsValue > 0) {
			return [`row-cols-${colsValue}`];
		}
	} else if (typeof cols === "object") {
		return ["xs", "sm", "md", "lg", "xl"].map(colWidth => {
			const isXs = colWidth === "xs";
			const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
			const value = cols[colWidth];

			if (typeof value === "number" && value > 0) {
				return `row-cols${colSizeInterfix}${value}`;
			}

			return null;
		}).filter(value => !!value);
	}

	return [];
}

function instance$11($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","noGutters","form","cols"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Row", slots, ['default']);
	let { class: className = "" } = $$props;
	let { noGutters = false } = $$props;
	let { form = false } = $$props;
	let { cols = 0 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("noGutters" in $$new_props) $$invalidate(3, noGutters = $$new_props.noGutters);
		if ("form" in $$new_props) $$invalidate(4, form = $$new_props.form);
		if ("cols" in $$new_props) $$invalidate(5, cols = $$new_props.cols);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		noGutters,
		form,
		cols,
		getCols,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("noGutters" in $$props) $$invalidate(3, noGutters = $$new_props.noGutters);
		if ("form" in $$props) $$invalidate(4, form = $$new_props.form);
		if ("cols" in $$props) $$invalidate(5, cols = $$new_props.cols);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, noGutters, form, cols*/ 60) {
			$: $$invalidate(0, classes = classnames(className, noGutters ? "no-gutters" : null, form ? "form-row" : "row", ...getCols(cols)));
		}
	};

	return [classes, $$restProps, className, noGutters, form, cols, $$scope, slots];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$11, create_fragment$11, safe_not_equal, { class: 2, noGutters: 3, form: 4, cols: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$11.name
		});
	}

	get class() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noGutters() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noGutters(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cols() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cols(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Spinner.svelte generated by Svelte v3.37.0 */
const file$12 = "node_modules/sveltestrap/src/Spinner.svelte";

// (20:10) Loading...
function fallback_block$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Loading...");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$6.name,
		type: "fallback",
		source: "(20:10) Loading...",
		ctx
	});

	return block;
}

function create_fragment$12(ctx) {
	let div;
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);
	let div_levels = [/*$$restProps*/ ctx[1], { role: "status" }, { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr_dev(span, "class", "sr-only");
			add_location(span, file$12, 18, 2, 399);
			set_attributes(div, div_data);
			add_location(div, file$12, 17, 0, 344);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				{ role: "status" },
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$12.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$12($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","type","size","color"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Spinner", slots, ['default']);
	let { class: className = "" } = $$props;
	let { type = "border" } = $$props;
	let { size = "" } = $$props;
	let { color = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("size" in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ("color" in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		type,
		size,
		color,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("size" in $$props) $$invalidate(4, size = $$new_props.size);
		if ("color" in $$props) $$invalidate(5, color = $$new_props.color);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size, type, color*/ 60) {
			$: $$invalidate(0, classes = classnames(className, size ? `spinner-${type}-${size}` : false, `spinner-${type}`, color ? `text-${color}` : false));
		}
	};

	return [classes, $$restProps, className, type, size, color, $$scope, slots];
}

class Spinner extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$12, create_fragment$12, safe_not_equal, { class: 2, type: 3, size: 4, color: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Spinner",
			options,
			id: create_fragment$12.name
		});
	}

	get class() {
		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Table.svelte generated by Svelte v3.37.0 */
const file$13 = "node_modules/sveltestrap/src/Table.svelte";

// (35:0) {:else}
function create_else_block$j(ctx) {
	let table;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let table_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[1] }];
	let table_data = {};

	for (let i = 0; i < table_levels.length; i += 1) {
		table_data = assign(table_data, table_levels[i]);
	}

	const block = {
		c: function create() {
			table = element("table");
			if (default_slot) default_slot.c();
			set_attributes(table, table_data);
			add_location(table, file$13, 35, 2, 861);
		},
		m: function mount(target, anchor) {
			insert_dev(target, table, anchor);

			if (default_slot) {
				default_slot.m(table, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(table, table_data = get_spread_update(table_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(table);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$j.name,
		type: "else",
		source: "(35:0) {:else}",
		ctx
	});

	return block;
}

// (29:0) {#if responsive}
function create_if_block$m(ctx) {
	let div;
	let table;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let table_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[1] }];
	let table_data = {};

	for (let i = 0; i < table_levels.length; i += 1) {
		table_data = assign(table_data, table_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			table = element("table");
			if (default_slot) default_slot.c();
			set_attributes(table, table_data);
			add_location(table, file$13, 30, 4, 773);
			attr_dev(div, "class", /*responsiveClassName*/ ctx[2]);
			add_location(div, file$13, 29, 2, 735);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, table);

			if (default_slot) {
				default_slot.m(table, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(table, table_data = get_spread_update(table_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));

			if (!current || dirty & /*responsiveClassName*/ 4) {
				attr_dev(div, "class", /*responsiveClassName*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$m.name,
		type: "if",
		source: "(29:0) {#if responsive}",
		ctx
	});

	return block;
}

function create_fragment$13(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$m, create_else_block$j];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*responsive*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$13.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$13($$self, $$props, $$invalidate) {
	let classes;
	let responsiveClassName;
	const omit_props_names = ["class","size","bordered","borderless","striped","dark","hover","responsive"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Table", slots, ['default']);
	let { class: className = "" } = $$props;
	let { size = "" } = $$props;
	let { bordered = false } = $$props;
	let { borderless = false } = $$props;
	let { striped = false } = $$props;
	let { dark = false } = $$props;
	let { hover = false } = $$props;
	let { responsive = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("size" in $$new_props) $$invalidate(5, size = $$new_props.size);
		if ("bordered" in $$new_props) $$invalidate(6, bordered = $$new_props.bordered);
		if ("borderless" in $$new_props) $$invalidate(7, borderless = $$new_props.borderless);
		if ("striped" in $$new_props) $$invalidate(8, striped = $$new_props.striped);
		if ("dark" in $$new_props) $$invalidate(9, dark = $$new_props.dark);
		if ("hover" in $$new_props) $$invalidate(10, hover = $$new_props.hover);
		if ("responsive" in $$new_props) $$invalidate(0, responsive = $$new_props.responsive);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		size,
		bordered,
		borderless,
		striped,
		dark,
		hover,
		responsive,
		classes,
		responsiveClassName
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("size" in $$props) $$invalidate(5, size = $$new_props.size);
		if ("bordered" in $$props) $$invalidate(6, bordered = $$new_props.bordered);
		if ("borderless" in $$props) $$invalidate(7, borderless = $$new_props.borderless);
		if ("striped" in $$props) $$invalidate(8, striped = $$new_props.striped);
		if ("dark" in $$props) $$invalidate(9, dark = $$new_props.dark);
		if ("hover" in $$props) $$invalidate(10, hover = $$new_props.hover);
		if ("responsive" in $$props) $$invalidate(0, responsive = $$new_props.responsive);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("responsiveClassName" in $$props) $$invalidate(2, responsiveClassName = $$new_props.responsiveClassName);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size, bordered, borderless, striped, dark, hover*/ 2032) {
			$: $$invalidate(1, classes = classnames(className, "table", size ? "table-" + size : false, bordered ? "table-bordered" : false, borderless ? "table-borderless" : false, striped ? "table-striped" : false, dark ? "table-dark" : false, hover ? "table-hover" : false));
		}

		if ($$self.$$.dirty & /*responsive*/ 1) {
			$: $$invalidate(2, responsiveClassName = responsive === true
			? "table-responsive"
			: `table-responsive-${responsive}`);
		}
	};

	return [
		responsive,
		classes,
		responsiveClassName,
		$$restProps,
		className,
		size,
		bordered,
		borderless,
		striped,
		dark,
		hover,
		$$scope,
		slots
	];
}

class Table extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$13, create_fragment$13, safe_not_equal, {
			class: 4,
			size: 5,
			bordered: 6,
			borderless: 7,
			striped: 8,
			dark: 9,
			hover: 10,
			responsive: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Table",
			options,
			id: create_fragment$13.name
		});
	}

	get class() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bordered() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bordered(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderless() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderless(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get striped() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set striped(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hover() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hover(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get responsive() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set responsive(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/TabContent.svelte generated by Svelte v3.37.0 */
const file$14 = "node_modules/sveltestrap/src/TabContent.svelte";

function create_fragment$14(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$14, 20, 0, 402);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$14.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$14($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","activeTab"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabContent", slots, ['default']);
	let { class: className = "" } = $$props;
	let { activeTab } = $$props;
	const activeTabId = writable(activeTab);
	setContext("tabContent", { activeTabId });

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("activeTab" in $$new_props) $$invalidate(3, activeTab = $$new_props.activeTab);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		setContext,
		writable,
		className,
		activeTab,
		activeTabId,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("activeTab" in $$props) $$invalidate(3, activeTab = $$new_props.activeTab);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*activeTab*/ 8) {
			$: activeTabId.set(activeTab);
		}

		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames("tab-content", className));
		}
	};

	return [classes, $$restProps, className, activeTab, $$scope, slots];
}

class TabContent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$14, create_fragment$14, safe_not_equal, { class: 2, activeTab: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabContent",
			options,
			id: create_fragment$14.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*activeTab*/ ctx[3] === undefined && !("activeTab" in props)) {
			console.warn("<TabContent> was created without expected prop 'activeTab'");
		}
	}

	get class() {
		throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeTab() {
		throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeTab(value) {
		throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/TabPane.svelte generated by Svelte v3.37.0 */
const file$15 = "node_modules/sveltestrap/src/TabPane.svelte";

function create_fragment$15(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$15, 15, 0, 317);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$15.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$15($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","tabId"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $activeTabId;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabPane", slots, ['default']);
	let { class: className = "" } = $$props;
	let { tabId } = $$props;
	const { activeTabId } = getContext("tabContent");
	validate_store(activeTabId, "activeTabId");
	component_subscribe($$self, activeTabId, value => $$invalidate(5, $activeTabId = value));

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("tabId" in $$new_props) $$invalidate(4, tabId = $$new_props.tabId);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		classnames,
		className,
		tabId,
		activeTabId,
		classes,
		$activeTabId
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("tabId" in $$props) $$invalidate(4, tabId = $$new_props.tabId);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, tabId, $activeTabId*/ 56) {
			$: $$invalidate(0, classes = classnames("tab-pane", className, { active: tabId === $activeTabId }));
		}
	};

	return [
		classes,
		activeTabId,
		$$restProps,
		className,
		tabId,
		$activeTabId,
		$$scope,
		slots
	];
}

class TabPane extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$15, create_fragment$15, safe_not_equal, { class: 3, tabId: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabPane",
			options,
			id: create_fragment$15.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*tabId*/ ctx[4] === undefined && !("tabId" in props)) {
			console.warn("<TabPane> was created without expected prop 'tabId'");
		}
	}

	get class() {
		throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabId() {
		throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabId(value) {
		throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Toast.svelte generated by Svelte v3.37.0 */
const file$16 = "node_modules/sveltestrap/src/Toast.svelte";

// (16:0) {#if isOpen}
function create_if_block$n(ctx) {
	let div;
	let div_transition;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [/*$$restProps*/ ctx[4], { class: /*classes*/ ctx[3] }, { role: "alert" }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$16, 16, 2, 339);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				{ role: "alert" }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(
					div,
					fade,
					{
						duration: /*fade*/ ctx[1] && /*duration*/ ctx[0]
					},
					true
				);

				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			if (!div_transition) div_transition = create_bidirectional_transition(
				div,
				fade,
				{
					duration: /*fade*/ ctx[1] && /*duration*/ ctx[0]
				},
				false
			);

			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$n.name,
		type: "if",
		source: "(16:0) {#if isOpen}",
		ctx
	});

	return block;
}

function create_fragment$16(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[2] && create_if_block$n(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$n(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$16.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$16($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","duration","fade","isOpen"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Toast", slots, ['default']);
	let { class: className = "" } = $$props;
	let { duration = 200 } = $$props;
	let { fade: fade$1 = true } = $$props;
	let { isOpen = true } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("duration" in $$new_props) $$invalidate(0, duration = $$new_props.duration);
		if ("fade" in $$new_props) $$invalidate(1, fade$1 = $$new_props.fade);
		if ("isOpen" in $$new_props) $$invalidate(2, isOpen = $$new_props.isOpen);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		fadeTrans: fade,
		className,
		duration,
		fade: fade$1,
		isOpen,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("duration" in $$props) $$invalidate(0, duration = $$new_props.duration);
		if ("fade" in $$props) $$invalidate(1, fade$1 = $$new_props.fade);
		if ("isOpen" in $$props) $$invalidate(2, isOpen = $$new_props.isOpen);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, isOpen*/ 36) {
			$: $$invalidate(3, classes = classnames(className, "toast", { show: isOpen }));
		}
	};

	return [duration, fade$1, isOpen, classes, $$restProps, className, $$scope, slots];
}

class Toast extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$16, create_fragment$16, safe_not_equal, {
			class: 5,
			duration: 0,
			fade: 1,
			isOpen: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toast",
			options,
			id: create_fragment$16.name
		});
	}

	get class() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fade() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fade(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ToastBody.svelte generated by Svelte v3.37.0 */
const file$17 = "node_modules/sveltestrap/src/ToastBody.svelte";

function create_fragment$17(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$17, 9, 0, 165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$17.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$17($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ToastBody", slots, ['default']);
	let { class: className = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$: $$invalidate(0, classes = classnames(className, "toast-body"));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class ToastBody extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$17, create_fragment$17, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ToastBody",
			options,
			id: create_fragment$17.name
		});
	}

	get class() {
		throw new Error("<ToastBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ToastBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ToastHeader.svelte generated by Svelte v3.37.0 */
const file$18 = "node_modules/sveltestrap/src/ToastHeader.svelte";
const get_close_slot_changes$1 = dirty => ({});
const get_close_slot_context$1 = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (31:2) {:else}
function create_else_block$k(ctx) {
	let current;
	const icon_slot_template = /*#slots*/ ctx[10].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[9], get_icon_slot_context);

	const block = {
		c: function create() {
			if (icon_slot) icon_slot.c();
		},
		m: function mount(target, anchor) {
			if (icon_slot) {
				icon_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(icon_slot, icon_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_icon_slot_changes, get_icon_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (icon_slot) icon_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$k.name,
		type: "else",
		source: "(31:2) {:else}",
		ctx
	});

	return block;
}

// (20:2) {#if icon}
function create_if_block_1$d(ctx) {
	let svg;
	let rect;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr_dev(rect, "fill", "currentColor");
			attr_dev(rect, "width", "100%");
			attr_dev(rect, "height", "100%");
			add_location(rect, file$18, 28, 6, 719);
			attr_dev(svg, "class", svg_class_value = `rounded text-${/*icon*/ ctx[0]}`);
			attr_dev(svg, "width", "20");
			attr_dev(svg, "height", "20");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "preserveAspectRatio", "xMidYMid slice");
			attr_dev(svg, "focusable", "false");
			attr_dev(svg, "role", "img");
			add_location(svg, file$18, 20, 4, 510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*icon*/ 1 && svg_class_value !== (svg_class_value = `rounded text-${/*icon*/ ctx[0]}`)) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$d.name,
		type: "if",
		source: "(20:2) {#if icon}",
		ctx
	});

	return block;
}

// (37:2) {#if toggle}
function create_if_block$o(ctx) {
	let current;
	const close_slot_template = /*#slots*/ ctx[10].close;
	const close_slot = create_slot(close_slot_template, ctx, /*$$scope*/ ctx[9], get_close_slot_context$1);
	const close_slot_or_fallback = close_slot || fallback_block$7(ctx);

	const block = {
		c: function create() {
			if (close_slot_or_fallback) close_slot_or_fallback.c();
		},
		m: function mount(target, anchor) {
			if (close_slot_or_fallback) {
				close_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (close_slot) {
				if (close_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(close_slot, close_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_close_slot_changes$1, get_close_slot_context$1);
				}
			} else {
				if (close_slot_or_fallback && close_slot_or_fallback.p && dirty & /*closeAriaLabel, toggle, closeIcon*/ 38) {
					close_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(close_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(close_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$o.name,
		type: "if",
		source: "(37:2) {#if toggle}",
		ctx
	});

	return block;
}

// (38:23)        
function fallback_block$7(ctx) {
	let button;
	let span;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			t = text(/*closeIcon*/ ctx[5]);
			attr_dev(span, "aria-hidden", "true");
			add_location(span, file$18, 43, 8, 1054);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "close");
			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[2]);
			add_location(button, file$18, 38, 6, 931);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*toggle*/ ctx[1])) /*toggle*/ ctx[1].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*closeIcon*/ 32) set_data_dev(t, /*closeIcon*/ ctx[5]);

			if (dirty & /*closeAriaLabel*/ 4) {
				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[2]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$7.name,
		type: "fallback",
		source: "(38:23)        ",
		ctx
	});

	return block;
}

function create_fragment$18(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let strong;
	let t1;
	let current;
	const if_block_creators = [create_if_block_1$d, create_else_block$k];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*icon*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let if_block1 = /*toggle*/ ctx[1] && create_if_block$o(ctx);
	let div_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block0.c();
			t0 = space();
			strong = element("strong");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr_dev(strong, "class", /*tagClassName*/ ctx[4]);
			add_location(strong, file$18, 33, 2, 831);
			set_attributes(div, div_data);
			add_location(div, file$18, 18, 0, 454);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t0);
			append_dev(div, strong);

			if (default_slot) {
				default_slot.m(strong, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t0);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*tagClassName*/ 16) {
				attr_dev(strong, "class", /*tagClassName*/ ctx[4]);
			}

			if (/*toggle*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*toggle*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$o(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$18.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$18($$self, $$props, $$invalidate) {
	let classes;
	let tagClassName;
	let closeIcon;
	const omit_props_names = ["class","icon","toggle","closeAriaLabel","charCode"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ToastHeader", slots, ['icon','default','close']);
	let { class: className = "" } = $$props;
	let { icon = null } = $$props;
	let { toggle = null } = $$props;
	let { closeAriaLabel = "Close" } = $$props;
	let { charCode = 215 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("icon" in $$new_props) $$invalidate(0, icon = $$new_props.icon);
		if ("toggle" in $$new_props) $$invalidate(1, toggle = $$new_props.toggle);
		if ("closeAriaLabel" in $$new_props) $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
		if ("charCode" in $$new_props) $$invalidate(8, charCode = $$new_props.charCode);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		icon,
		toggle,
		closeAriaLabel,
		charCode,
		classes,
		tagClassName,
		closeIcon
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("icon" in $$props) $$invalidate(0, icon = $$new_props.icon);
		if ("toggle" in $$props) $$invalidate(1, toggle = $$new_props.toggle);
		if ("closeAriaLabel" in $$props) $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
		if ("charCode" in $$props) $$invalidate(8, charCode = $$new_props.charCode);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("tagClassName" in $$props) $$invalidate(4, tagClassName = $$new_props.tagClassName);
		if ("closeIcon" in $$props) $$invalidate(5, closeIcon = $$new_props.closeIcon);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 128) {
			$: $$invalidate(3, classes = classnames(className, "toast-header"));
		}

		if ($$self.$$.dirty & /*icon*/ 1) {
			$: $$invalidate(4, tagClassName = classnames("mr-auto", { "ml-2": icon != null }));
		}

		if ($$self.$$.dirty & /*charCode*/ 256) {
			$: $$invalidate(5, closeIcon = typeof charCode === "number"
			? String.fromCharCode(charCode)
			: charCode);
		}
	};

	return [
		icon,
		toggle,
		closeAriaLabel,
		classes,
		tagClassName,
		closeIcon,
		$$restProps,
		className,
		charCode,
		$$scope,
		slots
	];
}

class ToastHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$18, create_fragment$18, safe_not_equal, {
			class: 7,
			icon: 0,
			toggle: 1,
			closeAriaLabel: 2,
			charCode: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ToastHeader",
			options,
			id: create_fragment$18.name
		});
	}

	get class() {
		throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeAriaLabel() {
		throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeAriaLabel(value) {
		throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get charCode() {
		throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set charCode(value) {
		throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Tooltip.svelte generated by Svelte v3.37.0 */

const { Error: Error_1$4 } = globals;
const file$19 = "node_modules/sveltestrap/src/Tooltip.svelte";

// (58:0) {#if isOpen}
function create_if_block$p(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_1$e, create_else_block$l];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div2_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ role: "tooltip" },
		{
			"x-placement": /*popperPlacement*/ ctx[2]
		}
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			if_block.c();
			attr_dev(div0, "class", "arrow");
			attr_dev(div0, "data-popper-arrow", "");
			add_location(div0, file$19, 64, 4, 1473);
			attr_dev(div1, "class", "tooltip-inner");
			add_location(div1, file$19, 65, 4, 1517);
			set_attributes(div2, div2_data);
			add_location(div2, file$19, 58, 2, 1343);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t);
			append_dev(div2, div1);
			if_blocks[current_block_type_index].m(div1, null);
			/*div2_binding*/ ctx[14](div2);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div1, null);
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				{ role: "tooltip" },
				(!current || dirty & /*popperPlacement*/ 4) && {
					"x-placement": /*popperPlacement*/ ctx[2]
				}
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if_blocks[current_block_type_index].d();
			/*div2_binding*/ ctx[14](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$p.name,
		type: "if",
		source: "(58:0) {#if isOpen}",
		ctx
	});

	return block;
}

// (69:6) {:else}
function create_else_block$l(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$l.name,
		type: "else",
		source: "(69:6) {:else}",
		ctx
	});

	return block;
}

// (67:6) {#if children}
function create_if_block_1$e(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
		},
		i: noop$1,
		o: noop$1,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$e.name,
		type: "if",
		source: "(67:6) {#if children}",
		ctx
	});

	return block;
}

function create_fragment$19(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$p(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error_1$4("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$p(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$19.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$19($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","target","placement","children","animation","isOpen"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tooltip", slots, ['default']);
	let { class: className = "" } = $$props;
	let { target = "" } = $$props;
	let { placement = "top" } = $$props;
	let { children = undefined } = $$props;
	let { animation = true } = $$props;
	let { isOpen = false } = $$props;
	let popperInstance;
	let popperPlacement = placement;
	let tooltipEl;
	let targetEl;

	const checkPopperPlacement = {
		name: "checkPopperPlacement",
		enabled: true,
		phase: "main",
		fn({ state }) {
			$$invalidate(2, popperPlacement = state.placement);
		}
	};

	onMount(() => {
		$$invalidate(11, targetEl = document.querySelector(`#${target}`));
		targetEl.addEventListener("mouseover", () => $$invalidate(0, isOpen = true));
		targetEl.addEventListener("mouseleave", () => $$invalidate(0, isOpen = false));
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tooltipEl = $$value;
			$$invalidate(3, tooltipEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("target" in $$new_props) $$invalidate(7, target = $$new_props.target);
		if ("placement" in $$new_props) $$invalidate(8, placement = $$new_props.placement);
		if ("children" in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ("animation" in $$new_props) $$invalidate(9, animation = $$new_props.animation);
		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		createPopper: createPopper$2,
		classnames,
		className,
		target,
		placement,
		children,
		animation,
		isOpen,
		popperInstance,
		popperPlacement,
		tooltipEl,
		targetEl,
		checkPopperPlacement,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("target" in $$props) $$invalidate(7, target = $$new_props.target);
		if ("placement" in $$props) $$invalidate(8, placement = $$new_props.placement);
		if ("children" in $$props) $$invalidate(1, children = $$new_props.children);
		if ("animation" in $$props) $$invalidate(9, animation = $$new_props.animation);
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ("popperInstance" in $$props) $$invalidate(10, popperInstance = $$new_props.popperInstance);
		if ("popperPlacement" in $$props) $$invalidate(2, popperPlacement = $$new_props.popperPlacement);
		if ("tooltipEl" in $$props) $$invalidate(3, tooltipEl = $$new_props.tooltipEl);
		if ("targetEl" in $$props) $$invalidate(11, targetEl = $$new_props.targetEl);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen, tooltipEl, targetEl, placement, popperInstance*/ 3337) {
			$: {
				if (isOpen && tooltipEl) {
					$$invalidate(10, popperInstance = createPopper$2(targetEl, tooltipEl, {
						placement,
						modifiers: [checkPopperPlacement]
					}));
				} else if (popperInstance) {
					popperInstance.destroy();
					$$invalidate(10, popperInstance = undefined);
				}
			}
		}

		if ($$self.$$.dirty & /*className, animation, popperPlacement, isOpen*/ 581) {
			$: $$invalidate(4, classes = classnames(className, "tooltip", animation ? "fade" : false, `bs-tooltip-${popperPlacement}`, isOpen ? "show" : false));
		}

		if ($$self.$$.dirty & /*target*/ 128) {
			$: if (!target) {
				throw new Error("Need target!");
			}
		}
	};

	return [
		isOpen,
		children,
		popperPlacement,
		tooltipEl,
		classes,
		$$restProps,
		className,
		target,
		placement,
		animation,
		popperInstance,
		targetEl,
		$$scope,
		slots,
		div2_binding
	];
}

class Tooltip extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
			class: 6,
			target: 7,
			placement: 8,
			children: 1,
			animation: 9,
			isOpen: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tooltip",
			options,
			id: create_fragment$19.name
		});
	}

	get class() {
		throw new Error_1$4("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$4("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error_1$4("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error_1$4("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placement() {
		throw new Error_1$4("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placement(value) {
		throw new Error_1$4("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error_1$4("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error_1$4("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animation() {
		throw new Error_1$4("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animation(value) {
		throw new Error_1$4("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error_1$4("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error_1$4("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/UncontrolledAlert.svelte generated by Svelte v3.37.0 */
const file$1a = "node_modules/sveltestrap/src/UncontrolledAlert.svelte";

// (7:0) <Alert {...$$restProps} {isOpen} toggle={() => (isOpen = false)}>
function create_default_slot$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(7:0) <Alert {...$$restProps} {isOpen} toggle={() => (isOpen = false)}>",
		ctx
	});

	return block;
}

function create_fragment$1a(ctx) {
	let alert;
	let current;

	const alert_spread_levels = [
		/*$$restProps*/ ctx[1],
		{ isOpen: /*isOpen*/ ctx[0] },
		{ toggle: /*func*/ ctx[3] }
	];

	let alert_props = {
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < alert_spread_levels.length; i += 1) {
		alert_props = assign(alert_props, alert_spread_levels[i]);
	}

	alert = new Alert({ props: alert_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(alert.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const alert_changes = (dirty & /*$$restProps, isOpen*/ 3)
			? get_spread_update(alert_spread_levels, [
					dirty & /*$$restProps*/ 2 && get_spread_object(/*$$restProps*/ ctx[1]),
					dirty & /*isOpen*/ 1 && { isOpen: /*isOpen*/ ctx[0] },
					dirty & /*isOpen*/ 1 && { toggle: /*func*/ ctx[3] }
				])
			: {};

			if (dirty & /*$$scope*/ 16) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(alert, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1a($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UncontrolledAlert", slots, ['default']);
	let isOpen = true;
	const func = () => $$invalidate(0, isOpen = false);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ Alert, isOpen });

	$$self.$inject_state = $$new_props => {
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [isOpen, $$restProps, slots, func, $$scope];
}

class UncontrolledAlert extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UncontrolledAlert",
			options,
			id: create_fragment$1a.name
		});
	}
}

/* node_modules/sveltestrap/src/UncontrolledButtonDropdown.svelte generated by Svelte v3.37.0 */
const file$1b = "node_modules/sveltestrap/src/UncontrolledButtonDropdown.svelte";

// (21:0) <ButtonDropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {direction}   {disabled}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>
function create_default_slot$5(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(21:0) <ButtonDropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {direction}   {disabled}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>",
		ctx
	});

	return block;
}

function create_fragment$1b(ctx) {
	let buttondropdown;
	let current;

	const buttondropdown_spread_levels = [
		/*$$restProps*/ ctx[12],
		{ isOpen: /*isOpen*/ ctx[11] },
		{ toggle: /*func*/ ctx[15] },
		{ class: /*className*/ ctx[0] },
		{ direction: /*direction*/ ctx[1] },
		{ disabled: /*disabled*/ ctx[2] },
		{ group: /*group*/ ctx[3] },
		{ nav: /*nav*/ ctx[4] },
		{ active: /*active*/ ctx[5] },
		{ addonType: /*addonType*/ ctx[6] },
		{ size: /*size*/ ctx[7] },
		{ inNavbar: /*inNavbar*/ ctx[8] },
		{
			setActiveFromChild: /*setActiveFromChild*/ ctx[9]
		},
		{ dropup: /*dropup*/ ctx[10] }
	];

	let buttondropdown_props = {
		$$slots: { default: [create_default_slot$5] },
		$$scope: { ctx }
	};

	for (let i = 0; i < buttondropdown_spread_levels.length; i += 1) {
		buttondropdown_props = assign(buttondropdown_props, buttondropdown_spread_levels[i]);
	}

	buttondropdown = new ButtonDropdown({
			props: buttondropdown_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(buttondropdown.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(buttondropdown, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const buttondropdown_changes = (dirty & /*$$restProps, isOpen, className, direction, disabled, group, nav, active, addonType, size, inNavbar, setActiveFromChild, dropup*/ 8191)
			? get_spread_update(buttondropdown_spread_levels, [
					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12]),
					dirty & /*isOpen*/ 2048 && { isOpen: /*isOpen*/ ctx[11] },
					dirty & /*isOpen*/ 2048 && { toggle: /*func*/ ctx[15] },
					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] },
					dirty & /*direction*/ 2 && { direction: /*direction*/ ctx[1] },
					dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
					dirty & /*group*/ 8 && { group: /*group*/ ctx[3] },
					dirty & /*nav*/ 16 && { nav: /*nav*/ ctx[4] },
					dirty & /*active*/ 32 && { active: /*active*/ ctx[5] },
					dirty & /*addonType*/ 64 && { addonType: /*addonType*/ ctx[6] },
					dirty & /*size*/ 128 && { size: /*size*/ ctx[7] },
					dirty & /*inNavbar*/ 256 && { inNavbar: /*inNavbar*/ ctx[8] },
					dirty & /*setActiveFromChild*/ 512 && {
						setActiveFromChild: /*setActiveFromChild*/ ctx[9]
					},
					dirty & /*dropup*/ 1024 && { dropup: /*dropup*/ ctx[10] }
				])
			: {};

			if (dirty & /*$$scope*/ 65536) {
				buttondropdown_changes.$$scope = { dirty, ctx };
			}

			buttondropdown.$set(buttondropdown_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(buttondropdown.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(buttondropdown.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(buttondropdown, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1b($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","direction","disabled","group","nav","active","addonType","size","inNavbar","setActiveFromChild","dropup","defaultOpen"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UncontrolledButtonDropdown", slots, ['default']);
	let { class: className = "" } = $$props;
	let { direction = "down" } = $$props;
	let { disabled = false } = $$props;
	let { group = false } = $$props;
	let { nav = false } = $$props;
	let { active = false } = $$props;
	let { addonType = false } = $$props;
	let { size = "" } = $$props;
	let { inNavbar = false } = $$props;
	let { setActiveFromChild = false } = $$props;
	let { dropup = false } = $$props;
	let { defaultOpen = false } = $$props;
	let isOpen = defaultOpen;
	const func = () => $$invalidate(11, isOpen = !isOpen);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("direction" in $$new_props) $$invalidate(1, direction = $$new_props.direction);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("group" in $$new_props) $$invalidate(3, group = $$new_props.group);
		if ("nav" in $$new_props) $$invalidate(4, nav = $$new_props.nav);
		if ("active" in $$new_props) $$invalidate(5, active = $$new_props.active);
		if ("addonType" in $$new_props) $$invalidate(6, addonType = $$new_props.addonType);
		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ("inNavbar" in $$new_props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
		if ("setActiveFromChild" in $$new_props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("dropup" in $$new_props) $$invalidate(10, dropup = $$new_props.dropup);
		if ("defaultOpen" in $$new_props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		ButtonDropdown,
		className,
		direction,
		disabled,
		group,
		nav,
		active,
		addonType,
		size,
		inNavbar,
		setActiveFromChild,
		dropup,
		defaultOpen,
		isOpen
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("direction" in $$props) $$invalidate(1, direction = $$new_props.direction);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("group" in $$props) $$invalidate(3, group = $$new_props.group);
		if ("nav" in $$props) $$invalidate(4, nav = $$new_props.nav);
		if ("active" in $$props) $$invalidate(5, active = $$new_props.active);
		if ("addonType" in $$props) $$invalidate(6, addonType = $$new_props.addonType);
		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
		if ("inNavbar" in $$props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
		if ("setActiveFromChild" in $$props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("dropup" in $$props) $$invalidate(10, dropup = $$new_props.dropup);
		if ("defaultOpen" in $$props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
		if ("isOpen" in $$props) $$invalidate(11, isOpen = $$new_props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		direction,
		disabled,
		group,
		nav,
		active,
		addonType,
		size,
		inNavbar,
		setActiveFromChild,
		dropup,
		isOpen,
		$$restProps,
		defaultOpen,
		slots,
		func,
		$$scope
	];
}

class UncontrolledButtonDropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
			class: 0,
			direction: 1,
			disabled: 2,
			group: 3,
			nav: 4,
			active: 5,
			addonType: 6,
			size: 7,
			inNavbar: 8,
			setActiveFromChild: 9,
			dropup: 10,
			defaultOpen: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UncontrolledButtonDropdown",
			options,
			id: create_fragment$1b.name
		});
	}

	get class() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nav() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nav(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addonType() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addonType(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inNavbar() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inNavbar(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setActiveFromChild() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setActiveFromChild(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropup() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropup(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultOpen() {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultOpen(value) {
		throw new Error("<UncontrolledButtonDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/UncontrolledCollapse.svelte generated by Svelte v3.37.0 */

const { Error: Error_1$5 } = globals;
const file$1c = "node_modules/sveltestrap/src/UncontrolledCollapse.svelte";

// (66:0) <Collapse   {...$$restProps}   {isOpen}   on:introstart   on:introend   on:outrostart   on:outroend   on:introstart={onEntering}   on:introend={onEntered}   on:outrostart={onExiting}   on:outroend={onExited}   class={className}>
function create_default_slot$6(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(66:0) <Collapse   {...$$restProps}   {isOpen}   on:introstart   on:introend   on:outrostart   on:outroend   on:introstart={onEntering}   on:introend={onEntered}   on:outrostart={onExiting}   on:outroend={onExited}   class={className}>",
		ctx
	});

	return block;
}

function create_fragment$1c(ctx) {
	let collapse;
	let current;

	const collapse_spread_levels = [
		/*$$restProps*/ ctx[6],
		{ isOpen: /*isOpen*/ ctx[5] },
		{ class: /*className*/ ctx[0] }
	];

	let collapse_props = {
		$$slots: { default: [create_default_slot$6] },
		$$scope: { ctx }
	};

	for (let i = 0; i < collapse_spread_levels.length; i += 1) {
		collapse_props = assign(collapse_props, collapse_spread_levels[i]);
	}

	collapse = new Collapse({ props: collapse_props, $$inline: true });
	collapse.$on("introstart", /*introstart_handler*/ ctx[10]);
	collapse.$on("introend", /*introend_handler*/ ctx[11]);
	collapse.$on("outrostart", /*outrostart_handler*/ ctx[12]);
	collapse.$on("outroend", /*outroend_handler*/ ctx[13]);

	collapse.$on("introstart", function () {
		if (is_function(/*onEntering*/ ctx[1])) /*onEntering*/ ctx[1].apply(this, arguments);
	});

	collapse.$on("introend", function () {
		if (is_function(/*onEntered*/ ctx[2])) /*onEntered*/ ctx[2].apply(this, arguments);
	});

	collapse.$on("outrostart", function () {
		if (is_function(/*onExiting*/ ctx[3])) /*onExiting*/ ctx[3].apply(this, arguments);
	});

	collapse.$on("outroend", function () {
		if (is_function(/*onExited*/ ctx[4])) /*onExited*/ ctx[4].apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(collapse.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$5("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(collapse, target, anchor);
			current = true;
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			const collapse_changes = (dirty & /*$$restProps, isOpen, className*/ 97)
			? get_spread_update(collapse_spread_levels, [
					dirty & /*$$restProps*/ 64 && get_spread_object(/*$$restProps*/ ctx[6]),
					dirty & /*isOpen*/ 32 && { isOpen: /*isOpen*/ ctx[5] },
					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] }
				])
			: {};

			if (dirty & /*$$scope*/ 16384) {
				collapse_changes.$$scope = { dirty, ctx };
			}

			collapse.$set(collapse_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(collapse.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(collapse.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(collapse, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1c($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","defaultOpen","toggler","onEntering","onEntered","onExiting","onExited"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UncontrolledCollapse", slots, ['default']);
	const noop = () => undefined;
	let { class: className = "" } = $$props;
	let { defaultOpen = false } = $$props;
	let { toggler = null } = $$props;
	let { onEntering = noop } = $$props;
	let { onEntered = noop } = $$props;
	let { onExiting = noop } = $$props;
	let { onExited = noop } = $$props;
	let unbindEvents;
	let isOpen = defaultOpen;

	function togglerFn() {
		$$invalidate(5, isOpen = !isOpen);
	}

	const defaultToggleEvents = ["touchstart", "click"];

	onMount(() => {
		if (typeof toggler === "string" && typeof window !== "undefined" && document && document.createElement) {
			let selection = document.querySelectorAll(toggler);

			if (!selection.length) {
				selection = document.querySelectorAll(`#${toggler}`);
			}

			if (!selection.length) {
				throw new Error(`The target '${toggler}' could not be identified in the dom, tip: check spelling`);
			}

			defaultToggleEvents.forEach(event => {
				selection.forEach(element => {
					element.addEventListener(event, togglerFn);
				});
			});

			unbindEvents = () => {
				defaultToggleEvents.forEach(event => {
					selection.forEach(element => {
						element.removeEventListener(event, togglerFn);
					});
				});
			};
		}
	});

	onDestroy(() => {
		if (typeof unbindEvents === "function") {
			unbindEvents();
			unbindEvents = undefined;
		}
	});

	function introstart_handler(event) {
		bubble($$self, event);
	}

	function introend_handler(event) {
		bubble($$self, event);
	}

	function outrostart_handler(event) {
		bubble($$self, event);
	}

	function outroend_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("defaultOpen" in $$new_props) $$invalidate(7, defaultOpen = $$new_props.defaultOpen);
		if ("toggler" in $$new_props) $$invalidate(8, toggler = $$new_props.toggler);
		if ("onEntering" in $$new_props) $$invalidate(1, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$new_props) $$invalidate(2, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$new_props) $$invalidate(3, onExiting = $$new_props.onExiting);
		if ("onExited" in $$new_props) $$invalidate(4, onExited = $$new_props.onExited);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Collapse,
		noop,
		className,
		defaultOpen,
		toggler,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		unbindEvents,
		isOpen,
		togglerFn,
		defaultToggleEvents
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("defaultOpen" in $$props) $$invalidate(7, defaultOpen = $$new_props.defaultOpen);
		if ("toggler" in $$props) $$invalidate(8, toggler = $$new_props.toggler);
		if ("onEntering" in $$props) $$invalidate(1, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$props) $$invalidate(2, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$props) $$invalidate(3, onExiting = $$new_props.onExiting);
		if ("onExited" in $$props) $$invalidate(4, onExited = $$new_props.onExited);
		if ("unbindEvents" in $$props) unbindEvents = $$new_props.unbindEvents;
		if ("isOpen" in $$props) $$invalidate(5, isOpen = $$new_props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		isOpen,
		$$restProps,
		defaultOpen,
		toggler,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler,
		$$scope
	];
}

class UncontrolledCollapse extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
			class: 0,
			defaultOpen: 7,
			toggler: 8,
			onEntering: 1,
			onEntered: 2,
			onExiting: 3,
			onExited: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UncontrolledCollapse",
			options,
			id: create_fragment$1c.name
		});
	}

	get class() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultOpen() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultOpen(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggler() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggler(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntering() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntering(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntered() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntered(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExiting() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExiting(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExited() {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExited(value) {
		throw new Error_1$5("<UncontrolledCollapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/UncontrolledFade.svelte generated by Svelte v3.37.0 */

const { Error: Error_1$6 } = globals;
const file$1d = "node_modules/sveltestrap/src/UncontrolledFade.svelte";

// (66:0) <Fade   {...$$restProps}   {isOpen}   on:introstart   on:introend   on:outrostart   on:outroend   on:introstart={onEntering}   on:introend={onEntered}   on:outrostart={onExiting}   on:outroend={onExited}   class={className}>
function create_default_slot$7(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(66:0) <Fade   {...$$restProps}   {isOpen}   on:introstart   on:introend   on:outrostart   on:outroend   on:introstart={onEntering}   on:introend={onEntered}   on:outrostart={onExiting}   on:outroend={onExited}   class={className}>",
		ctx
	});

	return block;
}

function create_fragment$1d(ctx) {
	let fade;
	let current;

	const fade_spread_levels = [
		/*$$restProps*/ ctx[6],
		{ isOpen: /*isOpen*/ ctx[5] },
		{ class: /*className*/ ctx[0] }
	];

	let fade_props = {
		$$slots: { default: [create_default_slot$7] },
		$$scope: { ctx }
	};

	for (let i = 0; i < fade_spread_levels.length; i += 1) {
		fade_props = assign(fade_props, fade_spread_levels[i]);
	}

	fade = new Fade({ props: fade_props, $$inline: true });
	fade.$on("introstart", /*introstart_handler*/ ctx[10]);
	fade.$on("introend", /*introend_handler*/ ctx[11]);
	fade.$on("outrostart", /*outrostart_handler*/ ctx[12]);
	fade.$on("outroend", /*outroend_handler*/ ctx[13]);

	fade.$on("introstart", function () {
		if (is_function(/*onEntering*/ ctx[1])) /*onEntering*/ ctx[1].apply(this, arguments);
	});

	fade.$on("introend", function () {
		if (is_function(/*onEntered*/ ctx[2])) /*onEntered*/ ctx[2].apply(this, arguments);
	});

	fade.$on("outrostart", function () {
		if (is_function(/*onExiting*/ ctx[3])) /*onExiting*/ ctx[3].apply(this, arguments);
	});

	fade.$on("outroend", function () {
		if (is_function(/*onExited*/ ctx[4])) /*onExited*/ ctx[4].apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(fade.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$6("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(fade, target, anchor);
			current = true;
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			const fade_changes = (dirty & /*$$restProps, isOpen, className*/ 97)
			? get_spread_update(fade_spread_levels, [
					dirty & /*$$restProps*/ 64 && get_spread_object(/*$$restProps*/ ctx[6]),
					dirty & /*isOpen*/ 32 && { isOpen: /*isOpen*/ ctx[5] },
					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] }
				])
			: {};

			if (dirty & /*$$scope*/ 16384) {
				fade_changes.$$scope = { dirty, ctx };
			}

			fade.$set(fade_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fade.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fade.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(fade, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1d($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","defaultOpen","toggler","onEntering","onEntered","onExiting","onExited"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UncontrolledFade", slots, ['default']);
	const noop = () => undefined;
	let { class: className = "" } = $$props;
	let { defaultOpen = false } = $$props;
	let { toggler = null } = $$props;
	let { onEntering = noop } = $$props;
	let { onEntered = noop } = $$props;
	let { onExiting = noop } = $$props;
	let { onExited = noop } = $$props;
	let unbindEvents;
	let isOpen = defaultOpen;

	function togglerFn() {
		$$invalidate(5, isOpen = !isOpen);
	}

	const defaultToggleEvents = ["touchstart", "click"];

	onMount(() => {
		if (typeof toggler === "string" && typeof window !== "undefined" && document && document.createElement) {
			let selection = document.querySelectorAll(toggler);

			if (!selection.length) {
				selection = document.querySelectorAll(`#${toggler}`);
			}

			if (!selection.length) {
				throw new Error(`The target '${toggler}' could not be identified in the dom, tip: check spelling`);
			}

			defaultToggleEvents.forEach(event => {
				selection.forEach(element => {
					element.addEventListener(event, togglerFn);
				});
			});

			unbindEvents = () => {
				defaultToggleEvents.forEach(event => {
					selection.forEach(element => {
						element.removeEventListener(event, togglerFn);
					});
				});
			};
		}
	});

	onDestroy(() => {
		if (typeof unbindEvents === "function") {
			unbindEvents();
			unbindEvents = undefined;
		}
	});

	function introstart_handler(event) {
		bubble($$self, event);
	}

	function introend_handler(event) {
		bubble($$self, event);
	}

	function outrostart_handler(event) {
		bubble($$self, event);
	}

	function outroend_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("defaultOpen" in $$new_props) $$invalidate(7, defaultOpen = $$new_props.defaultOpen);
		if ("toggler" in $$new_props) $$invalidate(8, toggler = $$new_props.toggler);
		if ("onEntering" in $$new_props) $$invalidate(1, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$new_props) $$invalidate(2, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$new_props) $$invalidate(3, onExiting = $$new_props.onExiting);
		if ("onExited" in $$new_props) $$invalidate(4, onExited = $$new_props.onExited);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Fade,
		noop,
		className,
		defaultOpen,
		toggler,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		unbindEvents,
		isOpen,
		togglerFn,
		defaultToggleEvents
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("defaultOpen" in $$props) $$invalidate(7, defaultOpen = $$new_props.defaultOpen);
		if ("toggler" in $$props) $$invalidate(8, toggler = $$new_props.toggler);
		if ("onEntering" in $$props) $$invalidate(1, onEntering = $$new_props.onEntering);
		if ("onEntered" in $$props) $$invalidate(2, onEntered = $$new_props.onEntered);
		if ("onExiting" in $$props) $$invalidate(3, onExiting = $$new_props.onExiting);
		if ("onExited" in $$props) $$invalidate(4, onExited = $$new_props.onExited);
		if ("unbindEvents" in $$props) unbindEvents = $$new_props.unbindEvents;
		if ("isOpen" in $$props) $$invalidate(5, isOpen = $$new_props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		isOpen,
		$$restProps,
		defaultOpen,
		toggler,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler,
		$$scope
	];
}

class UncontrolledFade extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
			class: 0,
			defaultOpen: 7,
			toggler: 8,
			onEntering: 1,
			onEntered: 2,
			onExiting: 3,
			onExited: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UncontrolledFade",
			options,
			id: create_fragment$1d.name
		});
	}

	get class() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultOpen() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultOpen(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggler() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggler(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntering() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntering(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onEntered() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onEntered(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExiting() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExiting(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onExited() {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onExited(value) {
		throw new Error_1$6("<UncontrolledFade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/UncontrolledDropdown.svelte generated by Svelte v3.37.0 */
const file$1e = "node_modules/sveltestrap/src/UncontrolledDropdown.svelte";

// (21:0) <Dropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {disabled}   {direction}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>
function create_default_slot$8(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(21:0) <Dropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {disabled}   {direction}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>",
		ctx
	});

	return block;
}

function create_fragment$1e(ctx) {
	let dropdown;
	let current;

	const dropdown_spread_levels = [
		/*$$restProps*/ ctx[12],
		{ isOpen: /*isOpen*/ ctx[11] },
		{ toggle: /*func*/ ctx[15] },
		{ class: /*className*/ ctx[0] },
		{ disabled: /*disabled*/ ctx[1] },
		{ direction: /*direction*/ ctx[2] },
		{ group: /*group*/ ctx[3] },
		{ nav: /*nav*/ ctx[4] },
		{ active: /*active*/ ctx[5] },
		{ addonType: /*addonType*/ ctx[6] },
		{ size: /*size*/ ctx[7] },
		{ inNavbar: /*inNavbar*/ ctx[8] },
		{
			setActiveFromChild: /*setActiveFromChild*/ ctx[9]
		},
		{ dropup: /*dropup*/ ctx[10] }
	];

	let dropdown_props = {
		$$slots: { default: [create_default_slot$8] },
		$$scope: { ctx }
	};

	for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
		dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
	}

	dropdown = new Dropdown({ props: dropdown_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(dropdown.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dropdown, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dropdown_changes = (dirty & /*$$restProps, isOpen, className, disabled, direction, group, nav, active, addonType, size, inNavbar, setActiveFromChild, dropup*/ 8191)
			? get_spread_update(dropdown_spread_levels, [
					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12]),
					dirty & /*isOpen*/ 2048 && { isOpen: /*isOpen*/ ctx[11] },
					dirty & /*isOpen*/ 2048 && { toggle: /*func*/ ctx[15] },
					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] },
					dirty & /*disabled*/ 2 && { disabled: /*disabled*/ ctx[1] },
					dirty & /*direction*/ 4 && { direction: /*direction*/ ctx[2] },
					dirty & /*group*/ 8 && { group: /*group*/ ctx[3] },
					dirty & /*nav*/ 16 && { nav: /*nav*/ ctx[4] },
					dirty & /*active*/ 32 && { active: /*active*/ ctx[5] },
					dirty & /*addonType*/ 64 && { addonType: /*addonType*/ ctx[6] },
					dirty & /*size*/ 128 && { size: /*size*/ ctx[7] },
					dirty & /*inNavbar*/ 256 && { inNavbar: /*inNavbar*/ ctx[8] },
					dirty & /*setActiveFromChild*/ 512 && {
						setActiveFromChild: /*setActiveFromChild*/ ctx[9]
					},
					dirty & /*dropup*/ 1024 && { dropup: /*dropup*/ ctx[10] }
				])
			: {};

			if (dirty & /*$$scope*/ 65536) {
				dropdown_changes.$$scope = { dirty, ctx };
			}

			dropdown.$set(dropdown_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dropdown, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1e($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","disabled","direction","group","nav","active","addonType","size","inNavbar","setActiveFromChild","dropup","defaultOpen"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UncontrolledDropdown", slots, ['default']);
	let { class: className = "" } = $$props;
	let { disabled = false } = $$props;
	let { direction = "down" } = $$props;
	let { group = false } = $$props;
	let { nav = false } = $$props;
	let { active = false } = $$props;
	let { addonType = false } = $$props;
	let { size = "" } = $$props;
	let { inNavbar = false } = $$props;
	let { setActiveFromChild = false } = $$props;
	let { dropup = false } = $$props;
	let { defaultOpen = false } = $$props;
	let isOpen = defaultOpen;
	const func = () => $$invalidate(11, isOpen = !isOpen);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("direction" in $$new_props) $$invalidate(2, direction = $$new_props.direction);
		if ("group" in $$new_props) $$invalidate(3, group = $$new_props.group);
		if ("nav" in $$new_props) $$invalidate(4, nav = $$new_props.nav);
		if ("active" in $$new_props) $$invalidate(5, active = $$new_props.active);
		if ("addonType" in $$new_props) $$invalidate(6, addonType = $$new_props.addonType);
		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ("inNavbar" in $$new_props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
		if ("setActiveFromChild" in $$new_props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("dropup" in $$new_props) $$invalidate(10, dropup = $$new_props.dropup);
		if ("defaultOpen" in $$new_props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Dropdown,
		className,
		disabled,
		direction,
		group,
		nav,
		active,
		addonType,
		size,
		inNavbar,
		setActiveFromChild,
		dropup,
		defaultOpen,
		isOpen
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("direction" in $$props) $$invalidate(2, direction = $$new_props.direction);
		if ("group" in $$props) $$invalidate(3, group = $$new_props.group);
		if ("nav" in $$props) $$invalidate(4, nav = $$new_props.nav);
		if ("active" in $$props) $$invalidate(5, active = $$new_props.active);
		if ("addonType" in $$props) $$invalidate(6, addonType = $$new_props.addonType);
		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
		if ("inNavbar" in $$props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
		if ("setActiveFromChild" in $$props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
		if ("dropup" in $$props) $$invalidate(10, dropup = $$new_props.dropup);
		if ("defaultOpen" in $$props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
		if ("isOpen" in $$props) $$invalidate(11, isOpen = $$new_props.isOpen);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		disabled,
		direction,
		group,
		nav,
		active,
		addonType,
		size,
		inNavbar,
		setActiveFromChild,
		dropup,
		isOpen,
		$$restProps,
		defaultOpen,
		slots,
		func,
		$$scope
	];
}

class UncontrolledDropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
			class: 0,
			disabled: 1,
			direction: 2,
			group: 3,
			nav: 4,
			active: 5,
			addonType: 6,
			size: 7,
			inNavbar: 8,
			setActiveFromChild: 9,
			dropup: 10,
			defaultOpen: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UncontrolledDropdown",
			options,
			id: create_fragment$1e.name
		});
	}

	get class() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nav() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nav(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addonType() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addonType(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inNavbar() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inNavbar(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setActiveFromChild() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setActiveFromChild(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropup() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropup(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultOpen() {
		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultOpen(value) {
		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* app/javascript/pages/login.svelte generated by Svelte v3.37.0 */
const file$1f = "app/javascript/pages/login.svelte";

// (26:2) <FormGroup>
function create_default_slot$9(ctx) {
	let input0;
	let updating_value;
	let t0;
	let input1;
	let updating_value_1;
	let t1;
	let input2;
	let updating_value_2;
	let current;

	function input0_value_binding(value) {
		/*input0_value_binding*/ ctx[4](value);
	}

	let input0_props = {
		placeholder: "ÐŸÐ¾Ñ‡Ñ‚Ð°",
		type: "email",
		name: "email"
	};

	if (/*email*/ ctx[0] !== void 0) {
		input0_props.value = /*email*/ ctx[0];
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, "value", input0_value_binding));

	function input1_value_binding(value) {
		/*input1_value_binding*/ ctx[5](value);
	}

	let input1_props = {
		placeholder: "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ",
		type: "password",
		name: "password",
		autocomplete: "on"
	};

	if (/*password*/ ctx[1] !== void 0) {
		input1_props.value = /*password*/ ctx[1];
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, "value", input1_value_binding));

	function input2_value_binding(value) {
		/*input2_value_binding*/ ctx[6](value);
	}

	let input2_props = {
		type: "hidden",
		name: "authenticity_token"
	};

	if (/*csrf*/ ctx[2] !== void 0) {
		input2_props.value = /*csrf*/ ctx[2];
	}

	input2 = new Input({ props: input2_props, $$inline: true });
	binding_callbacks.push(() => bind(input2, "value", input2_value_binding));

	const block = {
		c: function create() {
			create_component(input0.$$.fragment);
			t0 = space();
			create_component(input1.$$.fragment);
			t1 = space();
			create_component(input2.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(input1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(input2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input0_changes = {};

			if (!updating_value && dirty & /*email*/ 1) {
				updating_value = true;
				input0_changes.value = /*email*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*password*/ 2) {
				updating_value_1 = true;
				input1_changes.value = /*password*/ ctx[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
			const input2_changes = {};

			if (!updating_value_2 && dirty & /*csrf*/ 4) {
				updating_value_2 = true;
				input2_changes.value = /*csrf*/ ctx[2];
				add_flush_callback(() => updating_value_2 = false);
			}

			input2.$set(input2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(input2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(input2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(input1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(input2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(26:2) <FormGroup>",
		ctx
	});

	return block;
}

function create_fragment$1f(ctx) {
	let form;
	let formgroup;
	let t0;
	let button;
	let t2;
	let sveltetoast;
	let current;
	let mounted;
	let dispose;

	formgroup = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	sveltetoast = new SvelteToast({ $$inline: true });

	const block = {
		c: function create() {
			form = element("form");
			create_component(formgroup.$$.fragment);
			t0 = space();
			button = element("button");
			button.textContent = "Ð’Ð¾Ð¹Ñ‚Ð¸";
			t2 = space();
			create_component(sveltetoast.$$.fragment);
			attr_dev(button, "class", "btn btn-secondary");
			add_location(button, file$1f, 31, 2, 1016);
			attr_dev(form, "method", "post");
			attr_dev(form, "action", "/api/v1/auth/sign_in");
			add_location(form, file$1f, 24, 0, 675);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			mount_component(formgroup, form, null);
			append_dev(form, t0);
			append_dev(form, button);
			append_dev(form, t2);
			mount_component(sveltetoast, form, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", prevent_default(/*formSubmit*/ ctx[3]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const formgroup_changes = {};

			if (dirty & /*$$scope, csrf, password, email*/ 263) {
				formgroup_changes.$$scope = { dirty, ctx };
			}

			formgroup.$set(formgroup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formgroup.$$.fragment, local);
			transition_in(sveltetoast.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formgroup.$$.fragment, local);
			transition_out(sveltetoast.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_component(formgroup);
			destroy_component(sveltetoast);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Login", slots, []);
	let email, password;
	let csrf = document.querySelector("meta[name=csrf-token]").content;
	let param = document.querySelector("meta[name=csrf-param]").content;

	async function formSubmit(data) {
		let res = await User.login(email, password);

		if (res.errors) {
			toast.push(res.errors.join("<br />"));
		} else {
			User.signIn(res.token);
			toast.push("Ð’Ð¾ÑˆÐ»Ð¸ ÐºÐ°Ðº " + res.data["email"]);
			window.location = "/";
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Login> was created with unknown prop '${key}'`);
	});

	function input0_value_binding(value) {
		email = value;
		$$invalidate(0, email);
	}

	function input1_value_binding(value) {
		password = value;
		$$invalidate(1, password);
	}

	function input2_value_binding(value) {
		csrf = value;
		$$invalidate(2, csrf);
	}

	$$self.$capture_state = () => ({
		User,
		SvelteToast,
		toast,
		FormGroup,
		Input,
		email,
		password,
		csrf,
		param,
		formSubmit
	});

	$$self.$inject_state = $$props => {
		if ("email" in $$props) $$invalidate(0, email = $$props.email);
		if ("password" in $$props) $$invalidate(1, password = $$props.password);
		if ("csrf" in $$props) $$invalidate(2, csrf = $$props.csrf);
		if ("param" in $$props) param = $$props.param;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		email,
		password,
		csrf,
		formSubmit,
		input0_value_binding,
		input1_value_binding,
		input2_value_binding
	];
}

class Login extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Login",
			options,
			id: create_fragment$1f.name
		});
	}
}

export default Login;
//# sourceMappingURL=login-19a2b8e8.js.map
